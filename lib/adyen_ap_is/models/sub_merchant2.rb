# adyen_ap_is
#
# This file was automatically generated by APIMATIC v3.0 (
# https://www.apimatic.io ).

module AdyenApIs
  # Required for back-to-back/purchase-driven-load transactions, where the funds
  # are taken from the shopper's stored card when the wallet balance is
  # insufficient. The final merchant who will receive the money, also known as a
  # [sub-merchant](https://docs.adyen.com/get-started-with-adyen/payment-glossar
  # y/#submerchant).
  class SubMerchant2 < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # The city of the sub-merchant's address.
    # * Format: Alphanumeric
    # * Maximum length: 13 characters
    # @return [String]
    attr_accessor :city

    # The three-letter country code of the sub-merchant's address. For example,
    # **BRA** for Brazil. 
    # * Format: [ISO 3166-1
    # alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)
    # * Fixed length: 3 characters
    # @return [String]
    attr_accessor :country

    # The sub-merchant's 4-digit Merchant Category Code (MCC). 
    # * Format: Numeric
    # * Fixed length: 4 digits
    # @return [String]
    attr_accessor :mcc

    # The name of the sub-merchant. Based on scheme specifications, this value
    # will overwrite the shopper statement  that will appear in the card
    # statement.
    # * Format: Alphanumeric
    # * Maximum length: 22 characters
    # @return [String]
    attr_accessor :name

    # The tax ID of the sub-merchant.
    # * Format: Numeric
    # * Fixed length: 11 digits for the CPF or 14 digits for the CNPJ
    # @return [String]
    attr_accessor :tax_id

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['city'] = 'city'
      @_hash['country'] = 'country'
      @_hash['mcc'] = 'mcc'
      @_hash['name'] = 'name'
      @_hash['tax_id'] = 'taxId'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        city
        country
        mcc
        name
        tax_id
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(city: SKIP, country: SKIP, mcc: SKIP, name: SKIP,
                   tax_id: SKIP)
      @city = city unless city == SKIP
      @country = country unless country == SKIP
      @mcc = mcc unless mcc == SKIP
      @name = name unless name == SKIP
      @tax_id = tax_id unless tax_id == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      city = hash.key?('city') ? hash['city'] : SKIP
      country = hash.key?('country') ? hash['country'] : SKIP
      mcc = hash.key?('mcc') ? hash['mcc'] : SKIP
      name = hash.key?('name') ? hash['name'] : SKIP
      tax_id = hash.key?('taxId') ? hash['taxId'] : SKIP

      # Create object from extracted values.
      SubMerchant2.new(city: city,
                       country: country,
                       mcc: mcc,
                       name: name,
                       tax_id: tax_id)
    end

    # Validates an instance of the object from a given value.
    # @param [SubMerchant2 | Hash] The value against the validation is performed.
    def self.validate(value)
      return true if value.instance_of? self

      return false unless value.instance_of? Hash

      true
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} city: #{@city}, country: #{@country}, mcc: #{@mcc}, name: #{@name}, tax_id:"\
      " #{@tax_id}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} city: #{@city.inspect}, country: #{@country.inspect}, mcc: #{@mcc.inspect},"\
      " name: #{@name.inspect}, tax_id: #{@tax_id.inspect}>"
    end
  end
end
