# adyen_ap_is
#
# This file was automatically generated by APIMATIC v3.0 (
# https://www.apimatic.io ).

module AdyenApIs
  # AdditionalDataCommon Model.
  class AdditionalDataCommon < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # Triggers test scenarios that allow to replicate certain acquirer response
    # codes. See [Testing result codes and refusal
    # reasons](https://docs.adyen.com/development-resources/testing/result-codes
    # /) to learn about the possible values, and the `refusalReason` values you
    # can trigger.
    # @return [String]
    attr_accessor :requested_test_acquirer_response_code

    # Triggers test scenarios that allow to replicate certain communication
    # errors.
    # Allowed values:
    # * **NO_CONNECTION_AVAILABLE** – There wasn't a connection available to
    # service the outgoing communication.
    # This is a transient, retriable error since no messaging could be initiated
    # to an issuing system (or third-party acquiring system). Therefore, the
    # header Transient-Error: true is returned in the response. A subsequent
    # request using the same idempotency key will be processed as if it was the
    # first request.
    # * **IOEXCEPTION_RECEIVED** – Something went wrong during transmission of
    # the message or receiving the response.
    # This is a classified as non-transient because the message could have been
    # received by the issuing party and been acted upon. No transient error
    # header is returned. If using idempotency, the (error) response is stored
    # as the final result for the idempotency key. Subsequent messages with the
    # same idempotency key not be processed beyond returning the stored
    # response.
    # @return [String]
    attr_accessor :requested_test_error_response_code

    # Set to true to authorise a part of the requested amount in case the
    # cardholder does not have enough funds on their account. 
    # If a payment was partially authorised, the response includes resultCode:
    # PartiallyAuthorised and the authorised amount in
    # additionalData.authorisedAmountValue.
    # To enable this functionality, contact our Support Team.
    # @return [String]
    attr_accessor :allow_partial_auth

    # Flags a card payment request for either pre-authorisation or final
    # authorisation. For more information, refer to [Authorisation
    # types](https://docs.adyen.com/online-payments/adjust-authorisation#authori
    # sation-types).
    # Allowed values:
    # * **PreAuth** – flags the payment request to be handled as a
    # pre-authorisation.
    # * **FinalAuth** – flags the payment request to be handled as a final
    # authorisation.
    # @return [String]
    attr_accessor :authorisation_type

    # Set to **true** to enable [Auto
    # Rescue](https://docs.adyen.com/online-payments/auto-rescue/) for a
    # transaction. Use the `maxDaysToRescue` to specify a rescue window.
    # @return [String]
    attr_accessor :auto_rescue

    # Allows you to determine or override the acquirer account that should be
    # used for the transaction.
    # If you need to process a payment with an acquirer different from a default
    # one, you can set up a corresponding configuration on the Adyen payments
    # platform. Then you can pass a custom routing flag in a payment request's
    # additional data to target a specific acquirer.
    # To enable this functionality, contact
    # [Support](https://www.adyen.help/hc/en-us/requests/new).
    # @return [String]
    attr_accessor :custom_routing_flag

    # In case of [asynchronous authorisation
    # adjustment](https://docs.adyen.com/online-payments/adjust-authorisation#ad
    # just-authorisation), this field denotes why the additional payment is
    # made.
    # Possible values:
    #  * **NoShow**: An incremental charge is carried out because of a no-show
    # for a guaranteed reservation.
    #  * **DelayedCharge**: An incremental charge is carried out to process an
    # additional payment after the original services have been rendered and the
    # respective payment has been processed.
    # @return [IndustryUsage]
    attr_accessor :industry_usage

    # Set to **true** to require [manual
    # capture](https://docs.adyen.com/online-payments/capture) for the
    # transaction.
    # @return [String]
    attr_accessor :manual_capture

    # The rescue window for a transaction, in days, when `autoRescue` is set to
    # **true**. You can specify a value between 1 and 48.
    # * For [cards](https://docs.adyen.com/online-payments/auto-rescue/cards/),
    # the default is one calendar month.
    #  * For [SEPA](https://docs.adyen.com/online-payments/auto-rescue/sepa/),
    # the default is 42 days.
    # @return [String]
    attr_accessor :max_days_to_rescue

    # Allows you to link the transaction to the original or previous one in a
    # subscription/card-on-file chain. This field is required for token-based
    # transactions where Adyen does not tokenize the card.
    # Transaction identifier from card schemes, for example, Mastercard Trace ID
    # or the Visa Transaction ID.
    # Submit the original transaction ID of the contract in your payment request
    # if you are not tokenizing card details with Adyen and are making a
    # merchant-initiated transaction (MIT) for subsequent charges.
    # Make sure you are sending `shopperInteraction` **ContAuth** and
    # `recurringProcessingModel` **Subscription** or **UnscheduledCardOnFile**
    # to ensure that the transaction is classified as MIT.
    # @return [String]
    attr_accessor :network_tx_reference

    # Boolean indicator that can be optionally used for performing debit
    # transactions on combo cards (for example, combo cards in Brazil). This is
    # not mandatory but we recommend that you set this to true if you want to
    # use the `selectedBrand` value to specify how to process the transaction.
    # @return [String]
    attr_accessor :overwrite_brand

    # This field is required if the transaction is performed by a registered
    # payment facilitator. This field must contain the city of the actual
    # merchant's address.
    # * Format: alpha-numeric.
    # * Maximum length: 13 characters.
    # @return [String]
    attr_accessor :sub_merchant_city

    # This field is required if the transaction is performed by a registered
    # payment facilitator. This field must contain the three-letter country code
    # of the actual merchant's address.
    # * Format: alpha-numeric.
    # * Fixed length: 3 characters.
    # @return [String]
    attr_accessor :sub_merchant_country

    # This field is required for transactions performed by registered payment
    # facilitators. This field contains the email address of the sub-merchant.
    # * Format: Alphanumeric
    # * Maximum length: 40 characters
    # @return [String]
    attr_accessor :sub_merchant_email

    # This field contains an identifier of the actual merchant when a
    # transaction is submitted via a payment facilitator. The payment
    # facilitator must send in this unique ID.
    # A unique identifier per submerchant that is required if the transaction is
    # performed by a registered payment facilitator.
    # * Format: alpha-numeric.
    # * Fixed length: 15 characters.
    # @return [String]
    attr_accessor :sub_merchant_id

    # This field is required if the transaction is performed by a registered
    # payment facilitator. This field must contain the name of the actual
    # merchant.
    # * Format: alpha-numeric.
    # * Maximum length: 22 characters.
    # @return [String]
    attr_accessor :sub_merchant_name

    # This field is required for transactions performed by registered payment
    # facilitators. This field contains the phone number of the sub-merchant.*
    # Format: Alphanumeric
    # * Maximum length: 20 characters
    # @return [String]
    attr_accessor :sub_merchant_phone_number

    # This field is required if the transaction is performed by a registered
    # payment facilitator. This field must contain the postal code of the actual
    # merchant's address.
    # * Format: alpha-numeric.
    # * Maximum length: 10 characters.
    # @return [String]
    attr_accessor :sub_merchant_postal_code

    # This field is required if the transaction is performed by a registered
    # payment facilitator, and if applicable to the country. This field must
    # contain the state code of the actual merchant's address.
    # * Format: alpha-numeric.
    # * Maximum length: 3 characters.
    # @return [String]
    attr_accessor :sub_merchant_state

    # This field is required if the transaction is performed by a registered
    # payment facilitator. This field must contain the street of the actual
    # merchant's address.
    # * Format: alpha-numeric.
    # * Maximum length: 60 characters.
    # @return [String]
    attr_accessor :sub_merchant_street

    # This field is required if the transaction is performed by a registered
    # payment facilitator. This field must contain the tax ID of the actual
    # merchant.
    # * Format: alpha-numeric.
    # * Fixed length: 11 or 14 characters.
    # @return [String]
    attr_accessor :sub_merchant_tax_id

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['requested_test_acquirer_response_code'] =
        'RequestedTestAcquirerResponseCode'
      @_hash['requested_test_error_response_code'] =
        'RequestedTestErrorResponseCode'
      @_hash['allow_partial_auth'] = 'allowPartialAuth'
      @_hash['authorisation_type'] = 'authorisationType'
      @_hash['auto_rescue'] = 'autoRescue'
      @_hash['custom_routing_flag'] = 'customRoutingFlag'
      @_hash['industry_usage'] = 'industryUsage'
      @_hash['manual_capture'] = 'manualCapture'
      @_hash['max_days_to_rescue'] = 'maxDaysToRescue'
      @_hash['network_tx_reference'] = 'networkTxReference'
      @_hash['overwrite_brand'] = 'overwriteBrand'
      @_hash['sub_merchant_city'] = 'subMerchantCity'
      @_hash['sub_merchant_country'] = 'subMerchantCountry'
      @_hash['sub_merchant_email'] = 'subMerchantEmail'
      @_hash['sub_merchant_id'] = 'subMerchantID'
      @_hash['sub_merchant_name'] = 'subMerchantName'
      @_hash['sub_merchant_phone_number'] = 'subMerchantPhoneNumber'
      @_hash['sub_merchant_postal_code'] = 'subMerchantPostalCode'
      @_hash['sub_merchant_state'] = 'subMerchantState'
      @_hash['sub_merchant_street'] = 'subMerchantStreet'
      @_hash['sub_merchant_tax_id'] = 'subMerchantTaxId'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        requested_test_acquirer_response_code
        requested_test_error_response_code
        allow_partial_auth
        authorisation_type
        auto_rescue
        custom_routing_flag
        industry_usage
        manual_capture
        max_days_to_rescue
        network_tx_reference
        overwrite_brand
        sub_merchant_city
        sub_merchant_country
        sub_merchant_email
        sub_merchant_id
        sub_merchant_name
        sub_merchant_phone_number
        sub_merchant_postal_code
        sub_merchant_state
        sub_merchant_street
        sub_merchant_tax_id
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(requested_test_acquirer_response_code: SKIP,
                   requested_test_error_response_code: SKIP,
                   allow_partial_auth: SKIP, authorisation_type: SKIP,
                   auto_rescue: SKIP, custom_routing_flag: SKIP,
                   industry_usage: SKIP, manual_capture: SKIP,
                   max_days_to_rescue: SKIP, network_tx_reference: SKIP,
                   overwrite_brand: SKIP, sub_merchant_city: SKIP,
                   sub_merchant_country: SKIP, sub_merchant_email: SKIP,
                   sub_merchant_id: SKIP, sub_merchant_name: SKIP,
                   sub_merchant_phone_number: SKIP,
                   sub_merchant_postal_code: SKIP, sub_merchant_state: SKIP,
                   sub_merchant_street: SKIP, sub_merchant_tax_id: SKIP)
      unless requested_test_acquirer_response_code == SKIP
        @requested_test_acquirer_response_code =
          requested_test_acquirer_response_code
      end
      unless requested_test_error_response_code == SKIP
        @requested_test_error_response_code =
          requested_test_error_response_code
      end
      @allow_partial_auth = allow_partial_auth unless allow_partial_auth == SKIP
      @authorisation_type = authorisation_type unless authorisation_type == SKIP
      @auto_rescue = auto_rescue unless auto_rescue == SKIP
      @custom_routing_flag = custom_routing_flag unless custom_routing_flag == SKIP
      @industry_usage = industry_usage unless industry_usage == SKIP
      @manual_capture = manual_capture unless manual_capture == SKIP
      @max_days_to_rescue = max_days_to_rescue unless max_days_to_rescue == SKIP
      @network_tx_reference = network_tx_reference unless network_tx_reference == SKIP
      @overwrite_brand = overwrite_brand unless overwrite_brand == SKIP
      @sub_merchant_city = sub_merchant_city unless sub_merchant_city == SKIP
      @sub_merchant_country = sub_merchant_country unless sub_merchant_country == SKIP
      @sub_merchant_email = sub_merchant_email unless sub_merchant_email == SKIP
      @sub_merchant_id = sub_merchant_id unless sub_merchant_id == SKIP
      @sub_merchant_name = sub_merchant_name unless sub_merchant_name == SKIP
      unless sub_merchant_phone_number == SKIP
        @sub_merchant_phone_number =
          sub_merchant_phone_number
      end
      @sub_merchant_postal_code = sub_merchant_postal_code unless sub_merchant_postal_code == SKIP
      @sub_merchant_state = sub_merchant_state unless sub_merchant_state == SKIP
      @sub_merchant_street = sub_merchant_street unless sub_merchant_street == SKIP
      @sub_merchant_tax_id = sub_merchant_tax_id unless sub_merchant_tax_id == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      requested_test_acquirer_response_code =
        hash.key?('RequestedTestAcquirerResponseCode') ? hash['RequestedTestAcquirerResponseCode'] : SKIP
      requested_test_error_response_code =
        hash.key?('RequestedTestErrorResponseCode') ? hash['RequestedTestErrorResponseCode'] : SKIP
      allow_partial_auth =
        hash.key?('allowPartialAuth') ? hash['allowPartialAuth'] : SKIP
      authorisation_type =
        hash.key?('authorisationType') ? hash['authorisationType'] : SKIP
      auto_rescue = hash.key?('autoRescue') ? hash['autoRescue'] : SKIP
      custom_routing_flag =
        hash.key?('customRoutingFlag') ? hash['customRoutingFlag'] : SKIP
      industry_usage = hash.key?('industryUsage') ? hash['industryUsage'] : SKIP
      manual_capture = hash.key?('manualCapture') ? hash['manualCapture'] : SKIP
      max_days_to_rescue =
        hash.key?('maxDaysToRescue') ? hash['maxDaysToRescue'] : SKIP
      network_tx_reference =
        hash.key?('networkTxReference') ? hash['networkTxReference'] : SKIP
      overwrite_brand =
        hash.key?('overwriteBrand') ? hash['overwriteBrand'] : SKIP
      sub_merchant_city =
        hash.key?('subMerchantCity') ? hash['subMerchantCity'] : SKIP
      sub_merchant_country =
        hash.key?('subMerchantCountry') ? hash['subMerchantCountry'] : SKIP
      sub_merchant_email =
        hash.key?('subMerchantEmail') ? hash['subMerchantEmail'] : SKIP
      sub_merchant_id =
        hash.key?('subMerchantID') ? hash['subMerchantID'] : SKIP
      sub_merchant_name =
        hash.key?('subMerchantName') ? hash['subMerchantName'] : SKIP
      sub_merchant_phone_number =
        hash.key?('subMerchantPhoneNumber') ? hash['subMerchantPhoneNumber'] : SKIP
      sub_merchant_postal_code =
        hash.key?('subMerchantPostalCode') ? hash['subMerchantPostalCode'] : SKIP
      sub_merchant_state =
        hash.key?('subMerchantState') ? hash['subMerchantState'] : SKIP
      sub_merchant_street =
        hash.key?('subMerchantStreet') ? hash['subMerchantStreet'] : SKIP
      sub_merchant_tax_id =
        hash.key?('subMerchantTaxId') ? hash['subMerchantTaxId'] : SKIP

      # Create object from extracted values.
      AdditionalDataCommon.new(requested_test_acquirer_response_code: requested_test_acquirer_response_code,
                               requested_test_error_response_code: requested_test_error_response_code,
                               allow_partial_auth: allow_partial_auth,
                               authorisation_type: authorisation_type,
                               auto_rescue: auto_rescue,
                               custom_routing_flag: custom_routing_flag,
                               industry_usage: industry_usage,
                               manual_capture: manual_capture,
                               max_days_to_rescue: max_days_to_rescue,
                               network_tx_reference: network_tx_reference,
                               overwrite_brand: overwrite_brand,
                               sub_merchant_city: sub_merchant_city,
                               sub_merchant_country: sub_merchant_country,
                               sub_merchant_email: sub_merchant_email,
                               sub_merchant_id: sub_merchant_id,
                               sub_merchant_name: sub_merchant_name,
                               sub_merchant_phone_number: sub_merchant_phone_number,
                               sub_merchant_postal_code: sub_merchant_postal_code,
                               sub_merchant_state: sub_merchant_state,
                               sub_merchant_street: sub_merchant_street,
                               sub_merchant_tax_id: sub_merchant_tax_id)
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} requested_test_acquirer_response_code:"\
      " #{@requested_test_acquirer_response_code}, requested_test_error_response_code:"\
      " #{@requested_test_error_response_code}, allow_partial_auth: #{@allow_partial_auth},"\
      " authorisation_type: #{@authorisation_type}, auto_rescue: #{@auto_rescue},"\
      " custom_routing_flag: #{@custom_routing_flag}, industry_usage: #{@industry_usage},"\
      " manual_capture: #{@manual_capture}, max_days_to_rescue: #{@max_days_to_rescue},"\
      " network_tx_reference: #{@network_tx_reference}, overwrite_brand: #{@overwrite_brand},"\
      " sub_merchant_city: #{@sub_merchant_city}, sub_merchant_country: #{@sub_merchant_country},"\
      " sub_merchant_email: #{@sub_merchant_email}, sub_merchant_id: #{@sub_merchant_id},"\
      " sub_merchant_name: #{@sub_merchant_name}, sub_merchant_phone_number:"\
      " #{@sub_merchant_phone_number}, sub_merchant_postal_code: #{@sub_merchant_postal_code},"\
      " sub_merchant_state: #{@sub_merchant_state}, sub_merchant_street: #{@sub_merchant_street},"\
      " sub_merchant_tax_id: #{@sub_merchant_tax_id}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} requested_test_acquirer_response_code:"\
      " #{@requested_test_acquirer_response_code.inspect}, requested_test_error_response_code:"\
      " #{@requested_test_error_response_code.inspect}, allow_partial_auth:"\
      " #{@allow_partial_auth.inspect}, authorisation_type: #{@authorisation_type.inspect},"\
      " auto_rescue: #{@auto_rescue.inspect}, custom_routing_flag:"\
      " #{@custom_routing_flag.inspect}, industry_usage: #{@industry_usage.inspect},"\
      " manual_capture: #{@manual_capture.inspect}, max_days_to_rescue:"\
      " #{@max_days_to_rescue.inspect}, network_tx_reference: #{@network_tx_reference.inspect},"\
      " overwrite_brand: #{@overwrite_brand.inspect}, sub_merchant_city:"\
      " #{@sub_merchant_city.inspect}, sub_merchant_country: #{@sub_merchant_country.inspect},"\
      " sub_merchant_email: #{@sub_merchant_email.inspect}, sub_merchant_id:"\
      " #{@sub_merchant_id.inspect}, sub_merchant_name: #{@sub_merchant_name.inspect},"\
      " sub_merchant_phone_number: #{@sub_merchant_phone_number.inspect},"\
      " sub_merchant_postal_code: #{@sub_merchant_postal_code.inspect}, sub_merchant_state:"\
      " #{@sub_merchant_state.inspect}, sub_merchant_street: #{@sub_merchant_street.inspect},"\
      " sub_merchant_tax_id: #{@sub_merchant_tax_id.inspect}>"
    end
  end
end
