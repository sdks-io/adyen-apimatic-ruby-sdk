# adyen_ap_is
#
# This file was automatically generated by APIMATIC v3.0 (
# https://www.apimatic.io ).

module AdyenApIs
  # CheckoutForwardRequest Model.
  class CheckoutForwardRequest < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # The base URL of the third party API, where Adyen will send the request to
    # forward the payment details.
    # @return [String]
    attr_accessor :base_url

    # Your merchant account.
    # @return [String]
    attr_accessor :merchant_account

    # Merchant defined payment reference.
    # @return [String]
    attr_accessor :merchant_reference

    # The customizations that can be applied when making a forward request.
    # @return [CheckoutForwardRequestOptions2]
    attr_accessor :options

    # The card details.
    # @return [CheckoutForwardRequestCard2]
    attr_accessor :payment_method

    # The [details of the
    # request](https://docs.adyen.com/online-payments/tokenization/forward-payme
    # nt-details#request-to-adyen-card) that you want to forward to the
    # third-party.
    # @return [CheckoutOutgoingForwardRequest2]
    attr_accessor :request

    # Your reference to uniquely identify this shopper, for example user ID or
    # account ID. The value is case-sensitive and must be at least three
    # characters.
    # > Your reference must not include personally identifiable information
    # (PII) such as name or email address.
    # @return [String]
    attr_accessor :shopper_reference

    # The unique identifier of the token that you want to forward to the third
    # party. This is the `storedPaymentMethodId` you received in the webhook
    # after you created the token.
    # @return [String]
    attr_accessor :stored_payment_method_id

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['base_url'] = 'baseUrl'
      @_hash['merchant_account'] = 'merchantAccount'
      @_hash['merchant_reference'] = 'merchantReference'
      @_hash['options'] = 'options'
      @_hash['payment_method'] = 'paymentMethod'
      @_hash['request'] = 'request'
      @_hash['shopper_reference'] = 'shopperReference'
      @_hash['stored_payment_method_id'] = 'storedPaymentMethodId'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        merchant_reference
        options
        payment_method
        stored_payment_method_id
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(base_url:, merchant_account:, request:, shopper_reference:,
                   merchant_reference: SKIP, options: SKIP,
                   payment_method: SKIP, stored_payment_method_id: SKIP)
      @base_url = base_url
      @merchant_account = merchant_account
      @merchant_reference = merchant_reference unless merchant_reference == SKIP
      @options = options unless options == SKIP
      @payment_method = payment_method unless payment_method == SKIP
      @request = request
      @shopper_reference = shopper_reference
      @stored_payment_method_id = stored_payment_method_id unless stored_payment_method_id == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      base_url = hash.key?('baseUrl') ? hash['baseUrl'] : nil
      merchant_account =
        hash.key?('merchantAccount') ? hash['merchantAccount'] : nil
      request = CheckoutOutgoingForwardRequest2.from_hash(hash['request']) if hash['request']
      shopper_reference =
        hash.key?('shopperReference') ? hash['shopperReference'] : nil
      merchant_reference =
        hash.key?('merchantReference') ? hash['merchantReference'] : SKIP
      options = CheckoutForwardRequestOptions2.from_hash(hash['options']) if hash['options']
      payment_method = CheckoutForwardRequestCard2.from_hash(hash['paymentMethod']) if
        hash['paymentMethod']
      stored_payment_method_id =
        hash.key?('storedPaymentMethodId') ? hash['storedPaymentMethodId'] : SKIP

      # Create object from extracted values.
      CheckoutForwardRequest.new(base_url: base_url,
                                 merchant_account: merchant_account,
                                 request: request,
                                 shopper_reference: shopper_reference,
                                 merchant_reference: merchant_reference,
                                 options: options,
                                 payment_method: payment_method,
                                 stored_payment_method_id: stored_payment_method_id)
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} base_url: #{@base_url}, merchant_account: #{@merchant_account},"\
      " merchant_reference: #{@merchant_reference}, options: #{@options}, payment_method:"\
      " #{@payment_method}, request: #{@request}, shopper_reference: #{@shopper_reference},"\
      " stored_payment_method_id: #{@stored_payment_method_id}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} base_url: #{@base_url.inspect}, merchant_account:"\
      " #{@merchant_account.inspect}, merchant_reference: #{@merchant_reference.inspect}, options:"\
      " #{@options.inspect}, payment_method: #{@payment_method.inspect}, request:"\
      " #{@request.inspect}, shopper_reference: #{@shopper_reference.inspect},"\
      " stored_payment_method_id: #{@stored_payment_method_id.inspect}>"
    end
  end
end
