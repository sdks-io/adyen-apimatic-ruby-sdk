# adyen_ap_is
#
# This file was automatically generated by APIMATIC v3.0 (
# https://www.apimatic.io ).

module AdyenApIs
  # PixRecurring Model.
  class PixRecurring < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # The date on which the shopper's payment method will be charged, in
    # YYYY-MM-DD format.
    # @return [String]
    attr_accessor :billing_date

    # Flag used to define whether liquidation can happen only on business days
    # @return [TrueClass | FalseClass]
    attr_accessor :business_day_only

    # End date of the billing plan, in YYYY-MM-DD format. The end date must
    # align with the frequency and the start date of the billing plan. If left
    # blank, the subscription will continue indefinitely unless it is cancelled
    # by the shopper.
    # @return [String]
    attr_accessor :ends_at

    # The frequency at which the shopper will be charged.
    # @return [Frequency2]
    attr_accessor :frequency

    # For a billing plan where the payment amounts are variable, the minimum
    # amount to charge the shopper for each recurring payment. When a shopper
    # approves the billing plan, they can also specify a maximum amount in their
    # banking app.
    # @return [Amount41]
    attr_accessor :min_amount

    # The pspReference for the failed recurring payment. Find this in
    # AUTHORISATION webhook you received after the billing date.
    # @return [String]
    attr_accessor :original_psp_reference

    # For a billing plan where the payment amount is fixed, the amount the
    # shopper will be charged for each recurring payment.
    # @return [Amount42]
    attr_accessor :recurring_amount

    # The text that that will be shown on the shopper's bank statement for the
    # recurring payments. We recommend to add a descriptive text about the
    # subscription to let your shoppers recognize your recurring payments.
    # Maximum length: 35 characters.
    # @return [String]
    attr_accessor :recurring_statement

    # When set to true, you can retry for failed recurring payments. The default
    # value is true.
    # @return [TrueClass | FalseClass]
    attr_accessor :retry_policy

    # Start date of the billing plan, in YYYY-MM-DD format. The default value is
    # the transaction date.
    # @return [String]
    attr_accessor :starts_at

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['billing_date'] = 'billingDate'
      @_hash['business_day_only'] = 'businessDayOnly'
      @_hash['ends_at'] = 'endsAt'
      @_hash['frequency'] = 'frequency'
      @_hash['min_amount'] = 'minAmount'
      @_hash['original_psp_reference'] = 'originalPspReference'
      @_hash['recurring_amount'] = 'recurringAmount'
      @_hash['recurring_statement'] = 'recurringStatement'
      @_hash['retry_policy'] = 'retryPolicy'
      @_hash['starts_at'] = 'startsAt'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        billing_date
        business_day_only
        ends_at
        frequency
        min_amount
        original_psp_reference
        recurring_amount
        recurring_statement
        retry_policy
        starts_at
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(billing_date: SKIP, business_day_only: SKIP, ends_at: SKIP,
                   frequency: SKIP, min_amount: SKIP,
                   original_psp_reference: SKIP, recurring_amount: SKIP,
                   recurring_statement: SKIP, retry_policy: SKIP,
                   starts_at: SKIP)
      @billing_date = billing_date unless billing_date == SKIP
      @business_day_only = business_day_only unless business_day_only == SKIP
      @ends_at = ends_at unless ends_at == SKIP
      @frequency = frequency unless frequency == SKIP
      @min_amount = min_amount unless min_amount == SKIP
      @original_psp_reference = original_psp_reference unless original_psp_reference == SKIP
      @recurring_amount = recurring_amount unless recurring_amount == SKIP
      @recurring_statement = recurring_statement unless recurring_statement == SKIP
      @retry_policy = retry_policy unless retry_policy == SKIP
      @starts_at = starts_at unless starts_at == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      billing_date = hash.key?('billingDate') ? hash['billingDate'] : SKIP
      business_day_only =
        hash.key?('businessDayOnly') ? hash['businessDayOnly'] : SKIP
      ends_at = hash.key?('endsAt') ? hash['endsAt'] : SKIP
      frequency = hash.key?('frequency') ? hash['frequency'] : SKIP
      min_amount = Amount41.from_hash(hash['minAmount']) if hash['minAmount']
      original_psp_reference =
        hash.key?('originalPspReference') ? hash['originalPspReference'] : SKIP
      recurring_amount = Amount42.from_hash(hash['recurringAmount']) if hash['recurringAmount']
      recurring_statement =
        hash.key?('recurringStatement') ? hash['recurringStatement'] : SKIP
      retry_policy = hash.key?('retryPolicy') ? hash['retryPolicy'] : SKIP
      starts_at = hash.key?('startsAt') ? hash['startsAt'] : SKIP

      # Create object from extracted values.
      PixRecurring.new(billing_date: billing_date,
                       business_day_only: business_day_only,
                       ends_at: ends_at,
                       frequency: frequency,
                       min_amount: min_amount,
                       original_psp_reference: original_psp_reference,
                       recurring_amount: recurring_amount,
                       recurring_statement: recurring_statement,
                       retry_policy: retry_policy,
                       starts_at: starts_at)
    end

    # Validates an instance of the object from a given value.
    # @param [PixRecurring | Hash] The value against the validation is performed.
    def self.validate(value)
      return true if value.instance_of? self

      return false unless value.instance_of? Hash

      true
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} billing_date: #{@billing_date}, business_day_only: #{@business_day_only},"\
      " ends_at: #{@ends_at}, frequency: #{@frequency}, min_amount: #{@min_amount},"\
      " original_psp_reference: #{@original_psp_reference}, recurring_amount:"\
      " #{@recurring_amount}, recurring_statement: #{@recurring_statement}, retry_policy:"\
      " #{@retry_policy}, starts_at: #{@starts_at}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} billing_date: #{@billing_date.inspect}, business_day_only:"\
      " #{@business_day_only.inspect}, ends_at: #{@ends_at.inspect}, frequency:"\
      " #{@frequency.inspect}, min_amount: #{@min_amount.inspect}, original_psp_reference:"\
      " #{@original_psp_reference.inspect}, recurring_amount: #{@recurring_amount.inspect},"\
      " recurring_statement: #{@recurring_statement.inspect}, retry_policy:"\
      " #{@retry_policy.inspect}, starts_at: #{@starts_at.inspect}>"
    end
  end
end
