# adyen_ap_is
#
# This file was automatically generated by APIMATIC v3.0 (
# https://www.apimatic.io ).

module AdyenApIs
  # StoredPaymentMethodRequest Model.
  class StoredPaymentMethodRequest < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # The merchant account identifier, with which you want to process the
    # transaction.
    # @return [String]
    attr_accessor :merchant_account

    # Contains the information required to store a payment method.
    # @return [PaymentMethodToStore1]
    attr_accessor :payment_method

    # Defines a recurring payment type. Required when creating a token to store
    # payment details.
    # Allowed values:
    # * `Subscription` – A transaction for a fixed or variable amount, which
    # follows a fixed schedule.
    # * `CardOnFile` – With a card-on-file (CoF) transaction, card details are
    # stored to enable one-click or omnichannel journeys, or simply to
    # streamline the checkout process. Any subscription not following a fixed
    # schedule is also considered a card-on-file transaction.
    # * `UnscheduledCardOnFile` – An unscheduled card-on-file (UCoF) transaction
    # is a transaction that occurs on a non-fixed schedule and/or have variable
    # amounts. For example, automatic top-ups when a cardholder's balance drops
    # below a certain amount.
    # @return [RecurringProcessingModel1]
    attr_accessor :recurring_processing_model

    # The shopper's email address. We recommend that you provide this data, as
    # it is used in velocity fraud checks.
    # @return [String]
    attr_accessor :shopper_email

    # The IP address of a shopper.
    # @return [String]
    attr_accessor :shopper_ip

    # A unique identifier for the shopper (for example, user ID or account ID).
    # @return [String]
    attr_accessor :shopper_reference

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['merchant_account'] = 'merchantAccount'
      @_hash['payment_method'] = 'paymentMethod'
      @_hash['recurring_processing_model'] = 'recurringProcessingModel'
      @_hash['shopper_email'] = 'shopperEmail'
      @_hash['shopper_ip'] = 'shopperIP'
      @_hash['shopper_reference'] = 'shopperReference'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        shopper_email
        shopper_ip
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(merchant_account:, payment_method:,
                   recurring_processing_model:, shopper_reference:,
                   shopper_email: SKIP, shopper_ip: SKIP)
      @merchant_account = merchant_account
      @payment_method = payment_method
      @recurring_processing_model = recurring_processing_model
      @shopper_email = shopper_email unless shopper_email == SKIP
      @shopper_ip = shopper_ip unless shopper_ip == SKIP
      @shopper_reference = shopper_reference
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      merchant_account =
        hash.key?('merchantAccount') ? hash['merchantAccount'] : nil
      payment_method = PaymentMethodToStore1.from_hash(hash['paymentMethod']) if
        hash['paymentMethod']
      recurring_processing_model =
        hash.key?('recurringProcessingModel') ? hash['recurringProcessingModel'] : nil
      shopper_reference =
        hash.key?('shopperReference') ? hash['shopperReference'] : nil
      shopper_email = hash.key?('shopperEmail') ? hash['shopperEmail'] : SKIP
      shopper_ip = hash.key?('shopperIP') ? hash['shopperIP'] : SKIP

      # Create object from extracted values.
      StoredPaymentMethodRequest.new(merchant_account: merchant_account,
                                     payment_method: payment_method,
                                     recurring_processing_model: recurring_processing_model,
                                     shopper_reference: shopper_reference,
                                     shopper_email: shopper_email,
                                     shopper_ip: shopper_ip)
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} merchant_account: #{@merchant_account}, payment_method: #{@payment_method},"\
      " recurring_processing_model: #{@recurring_processing_model}, shopper_email:"\
      " #{@shopper_email}, shopper_ip: #{@shopper_ip}, shopper_reference: #{@shopper_reference}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} merchant_account: #{@merchant_account.inspect}, payment_method:"\
      " #{@payment_method.inspect}, recurring_processing_model:"\
      " #{@recurring_processing_model.inspect}, shopper_email: #{@shopper_email.inspect},"\
      " shopper_ip: #{@shopper_ip.inspect}, shopper_reference: #{@shopper_reference.inspect}>"
    end
  end
end
