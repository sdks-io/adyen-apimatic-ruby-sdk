# adyen_ap_is
#
# This file was automatically generated by APIMATIC v3.0 (
# https://www.apimatic.io ).

module AdyenApIs
  # ScheduleTerminalActionsResponse Model.
  class ScheduleTerminalActionsResponse < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # Information about the action to take.
    # @return [Object]
    attr_accessor :action_details

    # A list containing a terminal ID and an action ID for each terminal that
    # the action was scheduled for.
    # @return [Array[TerminalActionScheduleDetail]]
    attr_accessor :items

    # The date and time when the action should happen. 
    # Format: [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339), but without
    # the **Z** before the time offset. For example,
    # **2021-11-15T12:16:21+0100** 
    # The action is sent with the first [maintenance
    # call](https://docs.adyen.com/point-of-sale/automating-terminal-management/
    # terminal-actions-api#when-actions-take-effect) after the specified date
    # and time in the time zone of the terminal. 
    # An empty value causes the action to be sent as soon as possible: at the
    # next maintenance call.
    # @return [String]
    attr_accessor :scheduled_at

    # The unique ID of the
    # [store](https://docs.adyen.com/api-explorer/#/ManagementService/latest/get
    # /stores). If present, all terminals in the `terminalIds` list must be
    # assigned to this store.
    # @return [String]
    attr_accessor :store_id

    # The validation errors that occurred in the list of terminals, and for each
    # error the IDs of the terminals that the error applies to.
    # @return [Hash[String, Object]]
    attr_accessor :terminals_with_errors

    # The number of terminals for which scheduling the action failed.
    # @return [Integer]
    attr_accessor :total_errors

    # The number of terminals for which the action was successfully scheduled.
    # This doesn't mean the action has happened yet.
    # @return [Integer]
    attr_accessor :total_scheduled

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['action_details'] = 'actionDetails'
      @_hash['items'] = 'items'
      @_hash['scheduled_at'] = 'scheduledAt'
      @_hash['store_id'] = 'storeId'
      @_hash['terminals_with_errors'] = 'terminalsWithErrors'
      @_hash['total_errors'] = 'totalErrors'
      @_hash['total_scheduled'] = 'totalScheduled'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        action_details
        items
        scheduled_at
        store_id
        terminals_with_errors
        total_errors
        total_scheduled
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(action_details: SKIP, items: SKIP, scheduled_at: SKIP,
                   store_id: SKIP, terminals_with_errors: SKIP,
                   total_errors: SKIP, total_scheduled: SKIP)
      @action_details = action_details unless action_details == SKIP
      @items = items unless items == SKIP
      @scheduled_at = scheduled_at unless scheduled_at == SKIP
      @store_id = store_id unless store_id == SKIP
      @terminals_with_errors = terminals_with_errors unless terminals_with_errors == SKIP
      @total_errors = total_errors unless total_errors == SKIP
      @total_scheduled = total_scheduled unless total_scheduled == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      action_details = hash.key?('actionDetails') ? APIHelper.deserialize_union_type(
        UnionTypeLookUp.get(:ScheduleTerminalActionsResponseActionDetails), hash['actionDetails']
      ) : SKIP
      # Parameter is an array, so we need to iterate through it
      items = nil
      unless hash['items'].nil?
        items = []
        hash['items'].each do |structure|
          items << (TerminalActionScheduleDetail.from_hash(structure) if structure)
        end
      end

      items = SKIP unless hash.key?('items')
      scheduled_at = hash.key?('scheduledAt') ? hash['scheduledAt'] : SKIP
      store_id = hash.key?('storeId') ? hash['storeId'] : SKIP
      terminals_with_errors =
        hash.key?('terminalsWithErrors') ? hash['terminalsWithErrors'] : SKIP
      total_errors = hash.key?('totalErrors') ? hash['totalErrors'] : SKIP
      total_scheduled =
        hash.key?('totalScheduled') ? hash['totalScheduled'] : SKIP

      # Create object from extracted values.
      ScheduleTerminalActionsResponse.new(action_details: action_details,
                                          items: items,
                                          scheduled_at: scheduled_at,
                                          store_id: store_id,
                                          terminals_with_errors: terminals_with_errors,
                                          total_errors: total_errors,
                                          total_scheduled: total_scheduled)
    end

    # Validates an instance of the object from a given value.
    # @param [ScheduleTerminalActionsResponse | Hash] The value against the validation is performed.
    def self.validate(value)
      return true if value.instance_of? self

      return false unless value.instance_of? Hash

      true
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} action_details: #{@action_details}, items: #{@items}, scheduled_at:"\
      " #{@scheduled_at}, store_id: #{@store_id}, terminals_with_errors:"\
      " #{@terminals_with_errors}, total_errors: #{@total_errors}, total_scheduled:"\
      " #{@total_scheduled}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} action_details: #{@action_details.inspect}, items: #{@items.inspect},"\
      " scheduled_at: #{@scheduled_at.inspect}, store_id: #{@store_id.inspect},"\
      " terminals_with_errors: #{@terminals_with_errors.inspect}, total_errors:"\
      " #{@total_errors.inspect}, total_scheduled: #{@total_scheduled.inspect}>"
    end
  end
end
