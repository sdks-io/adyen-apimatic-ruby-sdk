# adyen_ap_is
#
# This file was automatically generated by APIMATIC v3.0 (
# https://www.apimatic.io ).

module AdyenApIs
  # Store Model.
  class Store < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # Reference to resources connected with the store.
    # @return [Links7]
    attr_accessor :links

    # The address of the store.
    # @return [StoreLocation1]
    attr_accessor :address

    # The unique identifiers of the [business
    # lines](https://docs.adyen.com/api-explorer/#/legalentity/latest/post/busin
    # esslines__resParam_id) that the store is associated with.
    #  If not specified, the business line of the merchant account is used.
    # Required when there are multiple business lines under the merchant
    # account.
    # @return [Array[String]]
    attr_accessor :business_line_ids

    # The description of the store.
    # @return [String]
    attr_accessor :description

    # The unique identifier of the store, used by certain payment methods and
    # tax authorities.
    # Required for CNPJ in Brazil, in the format 00.000.000/0000-00 separated by
    # dots, slashes, hyphens, or without separators.
    # Optional for SIRET in France, up to 14 digits.
    # Optional for Zip in Australia, up to 50 digits.
    # @return [String]
    attr_accessor :external_reference_id

    # The unique identifier of the store. This value is generated by Adyen.
    # @return [String]
    attr_accessor :id

    # The localized information of the store.
    # @return [LocalizedInformation4]
    attr_accessor :localized_information

    # The unique identifier of the merchant account that the store belongs to.
    # @return [String]
    attr_accessor :merchant_id

    # The phone number of the store, including '+' and country code in the
    # [E.164](https://en.wikipedia.org/wiki/E.164) format. If passed in a
    # different format, we convert and validate the phone number against E.164.
    # @return [String]
    attr_accessor :phone_number

    # A reference to recognize the store by. Also known as the store code.
    #  Allowed characters: lowercase and uppercase letters without diacritics,
    # numbers 0 through 9, hyphen (-), and underscore (_)
    # @return [String]
    attr_accessor :reference

    # The store name shown on the shopper's bank or credit card statement and on
    # the shopper receipt.
    # @return [String]
    attr_accessor :shopper_statement

    # Rules for Adyen for Platforms merchants to split the transaction amount
    # and fees.
    # @return [StoreSplitConfiguration1]
    attr_accessor :split_configuration

    # The status of the store. Possible values are:
    # - **active**. This value is assigned automatically when a store is
    # created. 
    # - **inactive**. The terminals under the store are blocked from accepting
    # new transactions, but capturing outstanding transactions is still
    # possible.
    # - **closed**. This status is irreversible. The terminals under the store
    # are reassigned to the merchant inventory.
    # @return [Status11]
    attr_accessor :status

    # The sub-merchant data relevant for registered payment facilitators
    # transacting on standalone terminals.
    # @return [SubMerchantData1]
    attr_accessor :sub_merchant_data

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['links'] = '_links'
      @_hash['address'] = 'address'
      @_hash['business_line_ids'] = 'businessLineIds'
      @_hash['description'] = 'description'
      @_hash['external_reference_id'] = 'externalReferenceId'
      @_hash['id'] = 'id'
      @_hash['localized_information'] = 'localizedInformation'
      @_hash['merchant_id'] = 'merchantId'
      @_hash['phone_number'] = 'phoneNumber'
      @_hash['reference'] = 'reference'
      @_hash['shopper_statement'] = 'shopperStatement'
      @_hash['split_configuration'] = 'splitConfiguration'
      @_hash['status'] = 'status'
      @_hash['sub_merchant_data'] = 'subMerchantData'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        links
        address
        business_line_ids
        description
        external_reference_id
        id
        localized_information
        merchant_id
        phone_number
        reference
        shopper_statement
        split_configuration
        status
        sub_merchant_data
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(links: SKIP, address: SKIP, business_line_ids: SKIP,
                   description: SKIP, external_reference_id: SKIP, id: SKIP,
                   localized_information: SKIP, merchant_id: SKIP,
                   phone_number: SKIP, reference: SKIP, shopper_statement: SKIP,
                   split_configuration: SKIP, status: SKIP,
                   sub_merchant_data: SKIP)
      @links = links unless links == SKIP
      @address = address unless address == SKIP
      @business_line_ids = business_line_ids unless business_line_ids == SKIP
      @description = description unless description == SKIP
      @external_reference_id = external_reference_id unless external_reference_id == SKIP
      @id = id unless id == SKIP
      @localized_information = localized_information unless localized_information == SKIP
      @merchant_id = merchant_id unless merchant_id == SKIP
      @phone_number = phone_number unless phone_number == SKIP
      @reference = reference unless reference == SKIP
      @shopper_statement = shopper_statement unless shopper_statement == SKIP
      @split_configuration = split_configuration unless split_configuration == SKIP
      @status = status unless status == SKIP
      @sub_merchant_data = sub_merchant_data unless sub_merchant_data == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      links = Links7.from_hash(hash['_links']) if hash['_links']
      address = StoreLocation1.from_hash(hash['address']) if hash['address']
      business_line_ids =
        hash.key?('businessLineIds') ? hash['businessLineIds'] : SKIP
      description = hash.key?('description') ? hash['description'] : SKIP
      external_reference_id =
        hash.key?('externalReferenceId') ? hash['externalReferenceId'] : SKIP
      id = hash.key?('id') ? hash['id'] : SKIP
      localized_information = LocalizedInformation4.from_hash(hash['localizedInformation']) if
        hash['localizedInformation']
      merchant_id = hash.key?('merchantId') ? hash['merchantId'] : SKIP
      phone_number = hash.key?('phoneNumber') ? hash['phoneNumber'] : SKIP
      reference = hash.key?('reference') ? hash['reference'] : SKIP
      shopper_statement =
        hash.key?('shopperStatement') ? hash['shopperStatement'] : SKIP
      split_configuration = StoreSplitConfiguration1.from_hash(hash['splitConfiguration']) if
        hash['splitConfiguration']
      status = hash.key?('status') ? hash['status'] : SKIP
      sub_merchant_data = SubMerchantData1.from_hash(hash['subMerchantData']) if
        hash['subMerchantData']

      # Create object from extracted values.
      Store.new(links: links,
                address: address,
                business_line_ids: business_line_ids,
                description: description,
                external_reference_id: external_reference_id,
                id: id,
                localized_information: localized_information,
                merchant_id: merchant_id,
                phone_number: phone_number,
                reference: reference,
                shopper_statement: shopper_statement,
                split_configuration: split_configuration,
                status: status,
                sub_merchant_data: sub_merchant_data)
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} links: #{@links}, address: #{@address}, business_line_ids:"\
      " #{@business_line_ids}, description: #{@description}, external_reference_id:"\
      " #{@external_reference_id}, id: #{@id}, localized_information: #{@localized_information},"\
      " merchant_id: #{@merchant_id}, phone_number: #{@phone_number}, reference: #{@reference},"\
      " shopper_statement: #{@shopper_statement}, split_configuration: #{@split_configuration},"\
      " status: #{@status}, sub_merchant_data: #{@sub_merchant_data}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} links: #{@links.inspect}, address: #{@address.inspect}, business_line_ids:"\
      " #{@business_line_ids.inspect}, description: #{@description.inspect},"\
      " external_reference_id: #{@external_reference_id.inspect}, id: #{@id.inspect},"\
      " localized_information: #{@localized_information.inspect}, merchant_id:"\
      " #{@merchant_id.inspect}, phone_number: #{@phone_number.inspect}, reference:"\
      " #{@reference.inspect}, shopper_statement: #{@shopper_statement.inspect},"\
      " split_configuration: #{@split_configuration.inspect}, status: #{@status.inspect},"\
      " sub_merchant_data: #{@sub_merchant_data.inspect}>"
    end
  end
end
