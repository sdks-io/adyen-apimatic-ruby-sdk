# adyen_ap_is
#
# This file was automatically generated by APIMATIC v3.0 (
# https://www.apimatic.io ).

module AdyenApIs
  # SubMerchantInfo Model.
  class SubMerchantInfo < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # Required for transactions performed by registered payment facilitators.
    # The sub-merchant's address.
    # @return [BillingAddress4]
    attr_accessor :address

    # Required for transactions performed by registered payment facilitators.
    # The amount of the payment corresponding to each sub-merchant. This value
    # will be different than the request amount if shopper is purchasing items
    # at different sub-merchants' shops.
    # @return [Amount31]
    attr_accessor :amount

    # Required for transactions performed by registered payment facilitators.
    # The email associated with the sub-merchant's account.
    # @return [String]
    attr_accessor :email

    # Required for transactions performed by registered payment facilitators. A
    # unique identifier that you create for the sub-merchant, used by schemes to
    # identify the sub-merchant. 
    # * Format: Alphanumeric
    # * Maximum length: 15 characters
    # @return [String]
    attr_accessor :id

    # Required for transactions performed by registered payment facilitators.
    # The sub-merchant's 4-digit Merchant Category Code (MCC). 
    # * Format: Numeric
    # * Fixed length: 4 digits
    # @return [String]
    attr_accessor :mcc

    # Required for transactions performed by registered payment facilitators.
    # The name of the sub-merchant. Based on scheme specifications, this value
    # will overwrite the shopper statement that will appear in the card
    # statement.
    # Exception: for acquirers in Brazil, this value does not overwrite the
    # shopper statement.
    # * Format: Alphanumeric
    # * Maximum length: 22 characters
    # @return [String]
    attr_accessor :name

    # Required for transactions performed by registered payment facilitators.
    # The phone number associated with the sub-merchant's account.
    # @return [String]
    attr_accessor :phone_number

    # Required for transactions performed by registered payment facilitators.
    # The phone number associated with the sub-merchant's account.
    # @return [String]
    attr_accessor :registered_since

    # Required for transactions performed by registered payment facilitators.
    # The tax ID of the sub-merchant.
    # * Format: Numeric
    # * Fixed length: 11 digits for the CPF or 14 digits for the CNPJ
    # @return [String]
    attr_accessor :tax_id

    # Required for transactions performed by registered payment facilitators.
    # The sub-merchant's URL on the platform, i.e. the sub-merchant's shop.
    # @return [String]
    attr_accessor :url

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['address'] = 'address'
      @_hash['amount'] = 'amount'
      @_hash['email'] = 'email'
      @_hash['id'] = 'id'
      @_hash['mcc'] = 'mcc'
      @_hash['name'] = 'name'
      @_hash['phone_number'] = 'phoneNumber'
      @_hash['registered_since'] = 'registeredSince'
      @_hash['tax_id'] = 'taxId'
      @_hash['url'] = 'url'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        address
        amount
        email
        id
        mcc
        name
        phone_number
        registered_since
        tax_id
        url
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(address: SKIP, amount: SKIP, email: SKIP, id: SKIP,
                   mcc: SKIP, name: SKIP, phone_number: SKIP,
                   registered_since: SKIP, tax_id: SKIP, url: SKIP)
      @address = address unless address == SKIP
      @amount = amount unless amount == SKIP
      @email = email unless email == SKIP
      @id = id unless id == SKIP
      @mcc = mcc unless mcc == SKIP
      @name = name unless name == SKIP
      @phone_number = phone_number unless phone_number == SKIP
      @registered_since = registered_since unless registered_since == SKIP
      @tax_id = tax_id unless tax_id == SKIP
      @url = url unless url == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      address = BillingAddress4.from_hash(hash['address']) if hash['address']
      amount = Amount31.from_hash(hash['amount']) if hash['amount']
      email = hash.key?('email') ? hash['email'] : SKIP
      id = hash.key?('id') ? hash['id'] : SKIP
      mcc = hash.key?('mcc') ? hash['mcc'] : SKIP
      name = hash.key?('name') ? hash['name'] : SKIP
      phone_number = hash.key?('phoneNumber') ? hash['phoneNumber'] : SKIP
      registered_since =
        hash.key?('registeredSince') ? hash['registeredSince'] : SKIP
      tax_id = hash.key?('taxId') ? hash['taxId'] : SKIP
      url = hash.key?('url') ? hash['url'] : SKIP

      # Create object from extracted values.
      SubMerchantInfo.new(address: address,
                          amount: amount,
                          email: email,
                          id: id,
                          mcc: mcc,
                          name: name,
                          phone_number: phone_number,
                          registered_since: registered_since,
                          tax_id: tax_id,
                          url: url)
    end

    # Validates an instance of the object from a given value.
    # @param [SubMerchantInfo | Hash] The value against the validation is performed.
    def self.validate(value)
      return true if value.instance_of? self

      return false unless value.instance_of? Hash

      true
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} address: #{@address}, amount: #{@amount}, email: #{@email}, id: #{@id},"\
      " mcc: #{@mcc}, name: #{@name}, phone_number: #{@phone_number}, registered_since:"\
      " #{@registered_since}, tax_id: #{@tax_id}, url: #{@url}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} address: #{@address.inspect}, amount: #{@amount.inspect}, email:"\
      " #{@email.inspect}, id: #{@id.inspect}, mcc: #{@mcc.inspect}, name: #{@name.inspect},"\
      " phone_number: #{@phone_number.inspect}, registered_since: #{@registered_since.inspect},"\
      " tax_id: #{@tax_id.inspect}, url: #{@url.inspect}>"
    end
  end
end
