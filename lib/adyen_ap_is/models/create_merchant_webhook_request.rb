# adyen_ap_is
#
# This file was automatically generated by APIMATIC v3.0 (
# https://www.apimatic.io ).

module AdyenApIs
  # CreateMerchantWebhookRequest Model.
  class CreateMerchantWebhookRequest < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # Indicates if expired SSL certificates are accepted. Default value:
    # **false**.
    # @return [TrueClass | FalseClass]
    attr_accessor :accepts_expired_certificate

    # Indicates if self-signed SSL certificates are accepted. Default value:
    # **false**.
    # @return [TrueClass | FalseClass]
    attr_accessor :accepts_self_signed_certificate

    # Indicates if untrusted SSL certificates are accepted. Default value:
    # **false**.
    # @return [TrueClass | FalseClass]
    attr_accessor :accepts_untrusted_root_certificate

    # Indicates if the webhook configuration is active. The field must be
    # **true** for us to send webhooks about events related an account.
    # @return [TrueClass | FalseClass]
    attr_accessor :active

    # Additional shopper and transaction information to be included in your
    # [standard
    # webhooks](https://docs.adyen.com/development-resources/webhooks/webhook-ty
    # pes/#event-codes). Find out more about the available [additional
    # settings](https://docs.adyen.com/development-resources/webhooks/additional
    # -settings).
    # @return [AdditionalSettings1]
    attr_accessor :additional_settings

    # Format or protocol for receiving webhooks. Possible values:
    # * **soap**
    # * **http**
    # * **json**
    # @return [CommunicationFormat]
    attr_accessor :communication_format

    # Your description for this webhook configuration.
    # @return [String]
    attr_accessor :description

    # SSL version to access the public webhook URL specified in the `url` field.
    # Possible values:
    # * **TLSv1.3**
    # * **TLSv1.2**
    # * **HTTP** - Only allowed on Test environment.
    # If not specified, the webhook will use `sslVersion`: **TLSv1.2**.
    # @return [EncryptionProtocol]
    attr_accessor :encryption_protocol

    # Network type for Terminal API notification webhooks. Possible values:
    # * **public**
    # * **local**
    # Default Value: **public**.
    # @return [NetworkType]
    attr_accessor :network_type

    # Password to access the webhook URL.
    # @return [String]
    attr_accessor :password

    # Indicates if the SOAP action header needs to be populated. Default value:
    # **false**.
    # Only applies if `communicationFormat`: **soap**.
    # @return [TrueClass | FalseClass]
    attr_accessor :populate_soap_action_header

    # The type of webhook that is being created. Possible values are:
    # - **standard**
    # - **account-settings-notification**
    # - **banktransfer-notification**
    # - **boletobancario-notification**
    # - **directdebit-notification**
    # - **ach-notification-of-change-notification**
    # - **direct-debit-notice-of-change-notification**
    # - **pending-notification**
    # - **ideal-notification**
    # - **ideal-pending-notification**
    # - **report-notification**
    # - **rreq-notification**
    # - **terminal-settings**
    # - **terminal-boarding**
    # Find out more about [standard
    # webhooks](https://docs.adyen.com/development-resources/webhooks/webhook-ty
    # pes/#event-codes) and [other types of
    # webhooks](https://docs.adyen.com/development-resources/webhooks/webhook-ty
    # pes/#other-webhooks).
    # @return [String]
    attr_accessor :type

    # Public URL where webhooks will be sent, for example
    # **https://www.domain.com/webhook-endpoint**.
    # @return [String]
    attr_accessor :url

    # Username to access the webhook URL.
    # @return [String]
    attr_accessor :username

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['accepts_expired_certificate'] = 'acceptsExpiredCertificate'
      @_hash['accepts_self_signed_certificate'] =
        'acceptsSelfSignedCertificate'
      @_hash['accepts_untrusted_root_certificate'] =
        'acceptsUntrustedRootCertificate'
      @_hash['active'] = 'active'
      @_hash['additional_settings'] = 'additionalSettings'
      @_hash['communication_format'] = 'communicationFormat'
      @_hash['description'] = 'description'
      @_hash['encryption_protocol'] = 'encryptionProtocol'
      @_hash['network_type'] = 'networkType'
      @_hash['password'] = 'password'
      @_hash['populate_soap_action_header'] = 'populateSoapActionHeader'
      @_hash['type'] = 'type'
      @_hash['url'] = 'url'
      @_hash['username'] = 'username'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        accepts_expired_certificate
        accepts_self_signed_certificate
        accepts_untrusted_root_certificate
        additional_settings
        description
        encryption_protocol
        network_type
        password
        populate_soap_action_header
        username
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(active:, communication_format:, type:, url:,
                   accepts_expired_certificate: SKIP,
                   accepts_self_signed_certificate: SKIP,
                   accepts_untrusted_root_certificate: SKIP,
                   additional_settings: SKIP, description: SKIP,
                   encryption_protocol: SKIP, network_type: SKIP,
                   password: SKIP, populate_soap_action_header: SKIP,
                   username: SKIP)
      unless accepts_expired_certificate == SKIP
        @accepts_expired_certificate =
          accepts_expired_certificate
      end
      unless accepts_self_signed_certificate == SKIP
        @accepts_self_signed_certificate =
          accepts_self_signed_certificate
      end
      unless accepts_untrusted_root_certificate == SKIP
        @accepts_untrusted_root_certificate =
          accepts_untrusted_root_certificate
      end
      @active = active
      @additional_settings = additional_settings unless additional_settings == SKIP
      @communication_format = communication_format
      @description = description unless description == SKIP
      @encryption_protocol = encryption_protocol unless encryption_protocol == SKIP
      @network_type = network_type unless network_type == SKIP
      @password = password unless password == SKIP
      unless populate_soap_action_header == SKIP
        @populate_soap_action_header =
          populate_soap_action_header
      end
      @type = type
      @url = url
      @username = username unless username == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      active = hash.key?('active') ? hash['active'] : nil
      communication_format =
        hash.key?('communicationFormat') ? hash['communicationFormat'] : nil
      type = hash.key?('type') ? hash['type'] : nil
      url = hash.key?('url') ? hash['url'] : nil
      accepts_expired_certificate =
        hash.key?('acceptsExpiredCertificate') ? hash['acceptsExpiredCertificate'] : SKIP
      accepts_self_signed_certificate =
        hash.key?('acceptsSelfSignedCertificate') ? hash['acceptsSelfSignedCertificate'] : SKIP
      accepts_untrusted_root_certificate =
        hash.key?('acceptsUntrustedRootCertificate') ? hash['acceptsUntrustedRootCertificate'] : SKIP
      additional_settings = AdditionalSettings1.from_hash(hash['additionalSettings']) if
        hash['additionalSettings']
      description = hash.key?('description') ? hash['description'] : SKIP
      encryption_protocol =
        hash.key?('encryptionProtocol') ? hash['encryptionProtocol'] : SKIP
      network_type = hash.key?('networkType') ? hash['networkType'] : SKIP
      password = hash.key?('password') ? hash['password'] : SKIP
      populate_soap_action_header =
        hash.key?('populateSoapActionHeader') ? hash['populateSoapActionHeader'] : SKIP
      username = hash.key?('username') ? hash['username'] : SKIP

      # Create object from extracted values.
      CreateMerchantWebhookRequest.new(active: active,
                                       communication_format: communication_format,
                                       type: type,
                                       url: url,
                                       accepts_expired_certificate: accepts_expired_certificate,
                                       accepts_self_signed_certificate: accepts_self_signed_certificate,
                                       accepts_untrusted_root_certificate: accepts_untrusted_root_certificate,
                                       additional_settings: additional_settings,
                                       description: description,
                                       encryption_protocol: encryption_protocol,
                                       network_type: network_type,
                                       password: password,
                                       populate_soap_action_header: populate_soap_action_header,
                                       username: username)
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} accepts_expired_certificate: #{@accepts_expired_certificate},"\
      " accepts_self_signed_certificate: #{@accepts_self_signed_certificate},"\
      " accepts_untrusted_root_certificate: #{@accepts_untrusted_root_certificate}, active:"\
      " #{@active}, additional_settings: #{@additional_settings}, communication_format:"\
      " #{@communication_format}, description: #{@description}, encryption_protocol:"\
      " #{@encryption_protocol}, network_type: #{@network_type}, password: #{@password},"\
      " populate_soap_action_header: #{@populate_soap_action_header}, type: #{@type}, url:"\
      " #{@url}, username: #{@username}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} accepts_expired_certificate: #{@accepts_expired_certificate.inspect},"\
      " accepts_self_signed_certificate: #{@accepts_self_signed_certificate.inspect},"\
      " accepts_untrusted_root_certificate: #{@accepts_untrusted_root_certificate.inspect},"\
      " active: #{@active.inspect}, additional_settings: #{@additional_settings.inspect},"\
      " communication_format: #{@communication_format.inspect}, description:"\
      " #{@description.inspect}, encryption_protocol: #{@encryption_protocol.inspect},"\
      " network_type: #{@network_type.inspect}, password: #{@password.inspect},"\
      " populate_soap_action_header: #{@populate_soap_action_header.inspect}, type:"\
      " #{@type.inspect}, url: #{@url.inspect}, username: #{@username.inspect}>"
    end
  end
end
