# adyen_ap_is
#
# This file was automatically generated by APIMATIC v3.0 (
# https://www.apimatic.io ).

module AdyenApIs
  # UpdateCompanyWebhookRequest Model.
  class UpdateCompanyWebhookRequest < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # Indicates if expired SSL certificates are accepted. Default value:
    # **false**.
    # @return [TrueClass | FalseClass]
    attr_accessor :accepts_expired_certificate

    # Indicates if self-signed SSL certificates are accepted. Default value:
    # **false**.
    # @return [TrueClass | FalseClass]
    attr_accessor :accepts_self_signed_certificate

    # Indicates if untrusted SSL certificates are accepted. Default value:
    # **false**.
    # @return [TrueClass | FalseClass]
    attr_accessor :accepts_untrusted_root_certificate

    # Indicates if the webhook configuration is active. The field must be
    # **true** for us to send webhooks about events related an account.
    # @return [TrueClass | FalseClass]
    attr_accessor :active

    # Additional shopper and transaction information to be included in your
    # [standard
    # webhooks](https://docs.adyen.com/development-resources/webhooks/webhook-ty
    # pes/#event-codes). Find out more about the available [additional
    # settings](https://docs.adyen.com/development-resources/webhooks/additional
    # -settings).
    # @return [AdditionalSettings1]
    attr_accessor :additional_settings

    # Format or protocol for receiving webhooks. Possible values:
    # * **soap**
    # * **http**
    # * **json**
    # @return [CommunicationFormat]
    attr_accessor :communication_format

    # Your description for this webhook configuration.
    # @return [String]
    attr_accessor :description

    # SSL version to access the public webhook URL specified in the `url` field.
    # Possible values:
    # * **TLSv1.3**
    # * **TLSv1.2**
    # * **HTTP** - Only allowed on Test environment.
    # If not specified, the webhook will use `sslVersion`: **TLSv1.2**.
    # @return [EncryptionProtocol]
    attr_accessor :encryption_protocol

    # Shows how merchant accounts are filtered when configuring the webhook.
    # Possible values:
    # * **includeAccounts**: The webhook is configured for the merchant accounts
    # listed in `filterMerchantAccounts`.
    # * **excludeAccounts**: The webhook is not configured for the merchant
    # accounts listed in `filterMerchantAccounts`.
    # * **allAccounts**: Includes all merchant accounts, and does not require
    # specifying `filterMerchantAccounts`.
    # @return [FilterMerchantAccountType2]
    attr_accessor :filter_merchant_account_type

    # A list of merchant account names that are included or excluded from
    # receiving the webhook. Inclusion or exclusion is based on the value
    # defined for `filterMerchantAccountType`.
    # Required if `filterMerchantAccountType` is either:
    # * **includeAccounts**
    # * **excludeAccounts**
    # Not needed for `filterMerchantAccountType`: **allAccounts**.
    # @return [Array[String]]
    attr_accessor :filter_merchant_accounts

    # Network type for Terminal API notification webhooks. Possible values:
    # * **public**
    # * **local**
    # Default Value: **public**.
    # @return [NetworkType]
    attr_accessor :network_type

    # Password to access the webhook URL.
    # @return [String]
    attr_accessor :password

    # Indicates if the SOAP action header needs to be populated. Default value:
    # **false**.
    # Only applies if `communicationFormat`: **soap**.
    # @return [TrueClass | FalseClass]
    attr_accessor :populate_soap_action_header

    # Public URL where webhooks will be sent, for example
    # **https://www.domain.com/webhook-endpoint**.
    # @return [String]
    attr_accessor :url

    # Username to access the webhook URL.
    # @return [String]
    attr_accessor :username

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['accepts_expired_certificate'] = 'acceptsExpiredCertificate'
      @_hash['accepts_self_signed_certificate'] =
        'acceptsSelfSignedCertificate'
      @_hash['accepts_untrusted_root_certificate'] =
        'acceptsUntrustedRootCertificate'
      @_hash['active'] = 'active'
      @_hash['additional_settings'] = 'additionalSettings'
      @_hash['communication_format'] = 'communicationFormat'
      @_hash['description'] = 'description'
      @_hash['encryption_protocol'] = 'encryptionProtocol'
      @_hash['filter_merchant_account_type'] = 'filterMerchantAccountType'
      @_hash['filter_merchant_accounts'] = 'filterMerchantAccounts'
      @_hash['network_type'] = 'networkType'
      @_hash['password'] = 'password'
      @_hash['populate_soap_action_header'] = 'populateSoapActionHeader'
      @_hash['url'] = 'url'
      @_hash['username'] = 'username'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        accepts_expired_certificate
        accepts_self_signed_certificate
        accepts_untrusted_root_certificate
        active
        additional_settings
        communication_format
        description
        encryption_protocol
        filter_merchant_account_type
        filter_merchant_accounts
        network_type
        password
        populate_soap_action_header
        url
        username
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(accepts_expired_certificate: SKIP,
                   accepts_self_signed_certificate: SKIP,
                   accepts_untrusted_root_certificate: SKIP, active: SKIP,
                   additional_settings: SKIP, communication_format: SKIP,
                   description: SKIP, encryption_protocol: SKIP,
                   filter_merchant_account_type: SKIP,
                   filter_merchant_accounts: SKIP, network_type: SKIP,
                   password: SKIP, populate_soap_action_header: SKIP, url: SKIP,
                   username: SKIP)
      unless accepts_expired_certificate == SKIP
        @accepts_expired_certificate =
          accepts_expired_certificate
      end
      unless accepts_self_signed_certificate == SKIP
        @accepts_self_signed_certificate =
          accepts_self_signed_certificate
      end
      unless accepts_untrusted_root_certificate == SKIP
        @accepts_untrusted_root_certificate =
          accepts_untrusted_root_certificate
      end
      @active = active unless active == SKIP
      @additional_settings = additional_settings unless additional_settings == SKIP
      @communication_format = communication_format unless communication_format == SKIP
      @description = description unless description == SKIP
      @encryption_protocol = encryption_protocol unless encryption_protocol == SKIP
      unless filter_merchant_account_type == SKIP
        @filter_merchant_account_type =
          filter_merchant_account_type
      end
      @filter_merchant_accounts = filter_merchant_accounts unless filter_merchant_accounts == SKIP
      @network_type = network_type unless network_type == SKIP
      @password = password unless password == SKIP
      unless populate_soap_action_header == SKIP
        @populate_soap_action_header =
          populate_soap_action_header
      end
      @url = url unless url == SKIP
      @username = username unless username == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      accepts_expired_certificate =
        hash.key?('acceptsExpiredCertificate') ? hash['acceptsExpiredCertificate'] : SKIP
      accepts_self_signed_certificate =
        hash.key?('acceptsSelfSignedCertificate') ? hash['acceptsSelfSignedCertificate'] : SKIP
      accepts_untrusted_root_certificate =
        hash.key?('acceptsUntrustedRootCertificate') ? hash['acceptsUntrustedRootCertificate'] : SKIP
      active = hash.key?('active') ? hash['active'] : SKIP
      additional_settings = AdditionalSettings1.from_hash(hash['additionalSettings']) if
        hash['additionalSettings']
      communication_format =
        hash.key?('communicationFormat') ? hash['communicationFormat'] : SKIP
      description = hash.key?('description') ? hash['description'] : SKIP
      encryption_protocol =
        hash.key?('encryptionProtocol') ? hash['encryptionProtocol'] : SKIP
      filter_merchant_account_type =
        hash.key?('filterMerchantAccountType') ? hash['filterMerchantAccountType'] : SKIP
      filter_merchant_accounts =
        hash.key?('filterMerchantAccounts') ? hash['filterMerchantAccounts'] : SKIP
      network_type = hash.key?('networkType') ? hash['networkType'] : SKIP
      password = hash.key?('password') ? hash['password'] : SKIP
      populate_soap_action_header =
        hash.key?('populateSoapActionHeader') ? hash['populateSoapActionHeader'] : SKIP
      url = hash.key?('url') ? hash['url'] : SKIP
      username = hash.key?('username') ? hash['username'] : SKIP

      # Create object from extracted values.
      UpdateCompanyWebhookRequest.new(accepts_expired_certificate: accepts_expired_certificate,
                                      accepts_self_signed_certificate: accepts_self_signed_certificate,
                                      accepts_untrusted_root_certificate: accepts_untrusted_root_certificate,
                                      active: active,
                                      additional_settings: additional_settings,
                                      communication_format: communication_format,
                                      description: description,
                                      encryption_protocol: encryption_protocol,
                                      filter_merchant_account_type: filter_merchant_account_type,
                                      filter_merchant_accounts: filter_merchant_accounts,
                                      network_type: network_type,
                                      password: password,
                                      populate_soap_action_header: populate_soap_action_header,
                                      url: url,
                                      username: username)
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} accepts_expired_certificate: #{@accepts_expired_certificate},"\
      " accepts_self_signed_certificate: #{@accepts_self_signed_certificate},"\
      " accepts_untrusted_root_certificate: #{@accepts_untrusted_root_certificate}, active:"\
      " #{@active}, additional_settings: #{@additional_settings}, communication_format:"\
      " #{@communication_format}, description: #{@description}, encryption_protocol:"\
      " #{@encryption_protocol}, filter_merchant_account_type: #{@filter_merchant_account_type},"\
      " filter_merchant_accounts: #{@filter_merchant_accounts}, network_type: #{@network_type},"\
      " password: #{@password}, populate_soap_action_header: #{@populate_soap_action_header}, url:"\
      " #{@url}, username: #{@username}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} accepts_expired_certificate: #{@accepts_expired_certificate.inspect},"\
      " accepts_self_signed_certificate: #{@accepts_self_signed_certificate.inspect},"\
      " accepts_untrusted_root_certificate: #{@accepts_untrusted_root_certificate.inspect},"\
      " active: #{@active.inspect}, additional_settings: #{@additional_settings.inspect},"\
      " communication_format: #{@communication_format.inspect}, description:"\
      " #{@description.inspect}, encryption_protocol: #{@encryption_protocol.inspect},"\
      " filter_merchant_account_type: #{@filter_merchant_account_type.inspect},"\
      " filter_merchant_accounts: #{@filter_merchant_accounts.inspect}, network_type:"\
      " #{@network_type.inspect}, password: #{@password.inspect}, populate_soap_action_header:"\
      " #{@populate_soap_action_header.inspect}, url: #{@url.inspect}, username:"\
      " #{@username.inspect}>"
    end
  end
end
