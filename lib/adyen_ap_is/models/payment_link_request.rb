# adyen_ap_is
#
# This file was automatically generated by APIMATIC v3.0 (
# https://www.apimatic.io ).

require 'date'
module AdyenApIs
  # PaymentLinkRequest Model.
  class PaymentLinkRequest < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # List of payment methods to be presented to the shopper. To refer to
    # payment methods, use their [payment method
    # type](https://docs.adyen.com/payment-methods/payment-method-types).
    # Example: `"allowedPaymentMethods":["ideal","applepay"]`
    # @return [Array[String]]
    attr_accessor :allowed_payment_methods

    # The payment amount and currency.
    # @return [Amount34]
    attr_accessor :amount

    # Information about your application. For more details, see [Building Adyen
    # solutions](https://docs.adyen.com/development-resources/building-adyen-sol
    # utions).
    # @return [ApplicationInfo1]
    attr_accessor :application_info

    # The address where to send the invoice.
    # @return [Address3]
    attr_accessor :billing_address

    # List of payment methods to be hidden from the shopper. To refer to payment
    # methods, use their [payment method
    # type](https://docs.adyen.com/payment-methods/payment-method-types).
    # Example: `"blockedPaymentMethods":["ideal","applepay"]`
    # @return [Array[String]]
    attr_accessor :blocked_payment_methods

    # The delay between the authorisation and scheduled auto-capture, specified
    # in hours.
    # @return [Integer]
    attr_accessor :capture_delay_hours

    # The shopper's two-letter country code.
    # @return [String]
    attr_accessor :country_code

    # The shopper's date of birth.
    # Format [ISO-8601](https://www.w3.org/TR/NOTE-datetime): YYYY-MM-DD
    # @return [Date]
    attr_accessor :date_of_birth

    # The date and time when the purchased goods should be delivered.
    # [ISO 8601](https://www.w3.org/TR/NOTE-datetime) format:
    # YYYY-MM-DDThh:mm:ss+TZD, for example, **2020-12-18T10:15:30+01:00**.
    # @return [DateTime]
    attr_accessor :deliver_at

    # The address where the purchased goods should be delivered.
    # @return [Address2]
    attr_accessor :delivery_address

    # A short description visible on the payment page.
    # Maximum length: 280 characters.
    # @return [String]
    attr_accessor :description

    # The date when the payment link expires.
    # [ISO 8601](https://www.w3.org/TR/NOTE-datetime) format with time zone
    # offset: YYYY-MM-DDThh:mm:ss+TZD, for example,
    # **2020-12-18T10:15:30+01:00**.
    # The maximum expiry date is 70 days after the payment link is created.
    # If not provided, the payment link expires 24 hours after it was created.
    # @return [DateTime]
    attr_accessor :expires_at

    # The person or entity funding the money.
    # @return [FundOrigin1]
    attr_accessor :fund_origin

    # the person or entity receiving the money
    # @return [FundRecipient1]
    attr_accessor :fund_recipient

    # A set of key-value pairs that specifies the installment options available
    # per payment method. The key must be a payment method name in lowercase.
    # For example, **card** to specify installment options for all cards, or
    # **visa** or **mc**. The value must be an object containing the installment
    # options.
    # @return [Hash[String, InstallmentOption]]
    attr_accessor :installment_options

    # Price and product information about the purchased items, to be included on
    # the invoice sent to the shopper.
    # > This field is required for 3x 4x Oney, Affirm, Afterpay, Clearpay,
    # Klarna, Ratepay, and Riverty.
    # @return [Array[LineItem]]
    attr_accessor :line_items

    # Indicates if the payment must be [captured
    # manually](https://docs.adyen.com/online-payments/capture).
    # @return [TrueClass | FalseClass]
    attr_accessor :manual_capture

    # The [merchant category
    # code](https://en.wikipedia.org/wiki/Merchant_category_code) (MCC) is a
    # four-digit number, which relates to a particular market segment. This code
    # reflects the predominant activity that is conducted by the merchant.
    # @return [String]
    attr_accessor :mcc

    # The merchant account identifier for which the payment link is created.
    # @return [String]
    attr_accessor :merchant_account

    # This reference allows linking multiple transactions to each other for
    # reporting purposes (for example, order auth-rate). The reference should be
    # unique per billing cycle.
    # @return [String]
    attr_accessor :merchant_order_reference

    # Metadata consists of entries, each of which includes a key and a value.
    # Limitations:
    # * Maximum 20 key-value pairs per request. Otherwise, error "177" occurs:
    # "Metadata size exceeds limit"
    # * Maximum 20 characters per key. Otherwise, error "178" occurs: "Metadata
    # key size exceeds limit"
    # * A key cannot have the name `checkout.linkId`. Any value that you provide
    # with this key is going to be replaced by the real payment link ID.
    # @return [Hash[String, String]]
    attr_accessor :metadata

    # Dictates the behavior of how a potential chargeback should be booked when
    # using Adyen Platforms.
    # @return [PlatformChargebackLogic4]
    attr_accessor :platform_chargeback_logic

    # Defines a recurring payment type. Required when `storePaymentMethodMode`
    # is set to **askForConsent** or **enabled**.
    # Possible values:
    # * **Subscription** – A transaction for a fixed or variable amount, which
    # follows a fixed schedule.
    # * **CardOnFile** – With a card-on-file (CoF) transaction, card details are
    # stored to enable one-click or omnichannel journeys, or simply to
    # streamline the checkout process. Any subscription not following a fixed
    # schedule is also considered a card-on-file transaction.
    # * **UnscheduledCardOnFile** – An unscheduled card-on-file (UCoF)
    # transaction is a transaction that occurs on a non-fixed schedule and/or
    # has variable amounts. For example, automatic top-ups when a cardholder's
    # balance drops below a certain amount.
    # @return [RecurringProcessingModel4]
    attr_accessor :recurring_processing_model

    # A reference that is used to uniquely identify the payment in future
    # communications about the payment status.
    # @return [String]
    attr_accessor :reference

    # List of fields that the shopper has to provide on the payment page before
    # completing the payment. For more information, refer to [Provide shopper
    # information](https://docs.adyen.com/unified-commerce/pay-by-link/payment-l
    # inks/api#shopper-information).
    # Possible values:
    # * **billingAddress** – The address where to send the invoice.
    # * **deliveryAddress** – The address where the purchased goods should be
    # delivered.
    # * **shopperEmail** – The shopper's email address.
    # * **shopperName** – The shopper's full name.
    # * **telephoneNumber** – The shopper's phone number.
    # @return [Array[RequiredShopperField]]
    attr_accessor :required_shopper_fields

    # Website URL used for redirection after payment is completed.
    # If provided, a **Continue** button will be shown on the payment page. If
    # shoppers select the button, they are redirected to the specified URL.
    # @return [String]
    attr_accessor :return_url

    # Indicates whether the payment link can be reused for multiple payments. If
    # not provided, this defaults to **false** which means the link can be used
    # for one successful payment only.
    # @return [TrueClass | FalseClass]
    attr_accessor :reusable

    # Any risk-related settings to apply to the payment.
    # @return [RiskData1]
    attr_accessor :risk_data

    # The shopper's email address.
    # @return [String]
    attr_accessor :shopper_email

    # The language to be used in the payment page, specified by a combination of
    # a language and country code. For example, `en-US`.
    # For a list of shopper locales that Pay by Link supports, refer to
    # [Language and
    # localization](https://docs.adyen.com/unified-commerce/pay-by-link/payment-
    # links/api#language).
    # @return [String]
    attr_accessor :shopper_locale

    # The shopper's full name. This object is required for some payment methods
    # such as AfterPay, Klarna, or if you're enrolled in the PayPal Seller
    # Protection program.
    # @return [Name4]
    attr_accessor :shopper_name

    # Your reference to uniquely identify this shopper, for example user ID or
    # account ID. The value is case-sensitive and must be at least three
    # characters.
    # > Your reference must not include personally identifiable information
    # (PII) such as name or email address.
    # @return [String]
    attr_accessor :shopper_reference

    # The text to be shown on the shopper's bank statement.
    #  We recommend sending a maximum of 22 characters, otherwise banks might
    # truncate the string.
    #  Allowed characters: **a-z**, **A-Z**, **0-9**, spaces, and special
    # characters **. , ' _ - ? + * /**.
    # @return [String]
    attr_accessor :shopper_statement

    # Set to **false** to hide the button that lets the shopper remove a stored
    # payment method.
    # @return [TrueClass | FalseClass]
    attr_accessor :show_remove_payment_method_button

    # The shopper's social security number.
    # @return [String]
    attr_accessor :social_security_number

    # Boolean value indicating whether the card payment method should be split
    # into separate debit and credit options.
    # @return [TrueClass | FalseClass]
    attr_accessor :split_card_funding_sources

    # An array of objects specifying how to split a payment when using [Adyen
    # for
    # Platforms](https://docs.adyen.com/platforms/process-payments#providing-spl
    # it-information), [Classic Platforms
    # integration](https://docs.adyen.com/classic-platforms/processing-payments#
    # providing-split-information), or
    # [Issuing](https://docs.adyen.com/issuing/manage-funds#split).
    # @return [Array[Split]]
    attr_accessor :splits

    # The physical store, for which this payment is processed.
    # @return [String]
    attr_accessor :store

    # Indicates if the details of the payment method will be stored for the
    # shopper. Possible values:
    # * **disabled** – No details will be stored (default).
    # * **askForConsent** – If the `shopperReference` is provided, the
    # Drop-in/Component shows a checkbox where the shopper can select to store
    # their payment details for card payments.
    # * **enabled** – If the `shopperReference` is provided, the details will be
    # stored without asking the shopper for consent. 
    #  When set to **askForConsent** or **enabled**, you must also include the
    # `recurringProcessingModel` parameter.
    # @return [StorePaymentMethodMode2]
    attr_accessor :store_payment_method_mode

    # The shopper's telephone number.
    #  The phone number must include a plus sign (+) and a country code (1-3
    # digits), followed by the number (4-15 digits). If the value you provide
    # does not follow the guidelines, we do not submit it for authentication.
    # > Required for Visa and JCB transactions that require 3D Secure 2
    # authentication, if you did not include the `shopperEmail`.
    # @return [String]
    attr_accessor :telephone_number

    # A
    # [theme](https://docs.adyen.com/unified-commerce/pay-by-link/payment-links/
    # api#themes) to customize the appearance of the payment page. If not
    # specified, the payment page is rendered according to the theme set as
    # default in your Customer Area.
    # @return [String]
    attr_accessor :theme_id

    # The cardholder phone number need to be part of the authentication message
    # for payment data. It is a requirement for Visa Secure Authentication Data
    # Field Mandate effective August 2024.
    # @return [CheckoutSessionThreeDs2RequestData3]
    attr_accessor :three_ds2_request_data

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['allowed_payment_methods'] = 'allowedPaymentMethods'
      @_hash['amount'] = 'amount'
      @_hash['application_info'] = 'applicationInfo'
      @_hash['billing_address'] = 'billingAddress'
      @_hash['blocked_payment_methods'] = 'blockedPaymentMethods'
      @_hash['capture_delay_hours'] = 'captureDelayHours'
      @_hash['country_code'] = 'countryCode'
      @_hash['date_of_birth'] = 'dateOfBirth'
      @_hash['deliver_at'] = 'deliverAt'
      @_hash['delivery_address'] = 'deliveryAddress'
      @_hash['description'] = 'description'
      @_hash['expires_at'] = 'expiresAt'
      @_hash['fund_origin'] = 'fundOrigin'
      @_hash['fund_recipient'] = 'fundRecipient'
      @_hash['installment_options'] = 'installmentOptions'
      @_hash['line_items'] = 'lineItems'
      @_hash['manual_capture'] = 'manualCapture'
      @_hash['mcc'] = 'mcc'
      @_hash['merchant_account'] = 'merchantAccount'
      @_hash['merchant_order_reference'] = 'merchantOrderReference'
      @_hash['metadata'] = 'metadata'
      @_hash['platform_chargeback_logic'] = 'platformChargebackLogic'
      @_hash['recurring_processing_model'] = 'recurringProcessingModel'
      @_hash['reference'] = 'reference'
      @_hash['required_shopper_fields'] = 'requiredShopperFields'
      @_hash['return_url'] = 'returnUrl'
      @_hash['reusable'] = 'reusable'
      @_hash['risk_data'] = 'riskData'
      @_hash['shopper_email'] = 'shopperEmail'
      @_hash['shopper_locale'] = 'shopperLocale'
      @_hash['shopper_name'] = 'shopperName'
      @_hash['shopper_reference'] = 'shopperReference'
      @_hash['shopper_statement'] = 'shopperStatement'
      @_hash['show_remove_payment_method_button'] =
        'showRemovePaymentMethodButton'
      @_hash['social_security_number'] = 'socialSecurityNumber'
      @_hash['split_card_funding_sources'] = 'splitCardFundingSources'
      @_hash['splits'] = 'splits'
      @_hash['store'] = 'store'
      @_hash['store_payment_method_mode'] = 'storePaymentMethodMode'
      @_hash['telephone_number'] = 'telephoneNumber'
      @_hash['theme_id'] = 'themeId'
      @_hash['three_ds2_request_data'] = 'threeDS2RequestData'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        allowed_payment_methods
        application_info
        billing_address
        blocked_payment_methods
        capture_delay_hours
        country_code
        date_of_birth
        deliver_at
        delivery_address
        description
        expires_at
        fund_origin
        fund_recipient
        installment_options
        line_items
        manual_capture
        mcc
        merchant_order_reference
        metadata
        platform_chargeback_logic
        recurring_processing_model
        required_shopper_fields
        return_url
        reusable
        risk_data
        shopper_email
        shopper_locale
        shopper_name
        shopper_reference
        shopper_statement
        show_remove_payment_method_button
        social_security_number
        split_card_funding_sources
        splits
        store
        store_payment_method_mode
        telephone_number
        theme_id
        three_ds2_request_data
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(amount:, merchant_account:, reference:,
                   allowed_payment_methods: SKIP, application_info: SKIP,
                   billing_address: SKIP, blocked_payment_methods: SKIP,
                   capture_delay_hours: SKIP, country_code: SKIP,
                   date_of_birth: SKIP, deliver_at: SKIP,
                   delivery_address: SKIP, description: SKIP, expires_at: SKIP,
                   fund_origin: SKIP, fund_recipient: SKIP,
                   installment_options: SKIP, line_items: SKIP,
                   manual_capture: SKIP, mcc: SKIP,
                   merchant_order_reference: SKIP, metadata: SKIP,
                   platform_chargeback_logic: SKIP,
                   recurring_processing_model: SKIP,
                   required_shopper_fields: SKIP, return_url: SKIP,
                   reusable: SKIP, risk_data: SKIP, shopper_email: SKIP,
                   shopper_locale: SKIP, shopper_name: SKIP,
                   shopper_reference: SKIP, shopper_statement: SKIP,
                   show_remove_payment_method_button: true,
                   social_security_number: SKIP,
                   split_card_funding_sources: false, splits: SKIP, store: SKIP,
                   store_payment_method_mode: SKIP, telephone_number: SKIP,
                   theme_id: SKIP, three_ds2_request_data: SKIP)
      @allowed_payment_methods = allowed_payment_methods unless allowed_payment_methods == SKIP
      @amount = amount
      @application_info = application_info unless application_info == SKIP
      @billing_address = billing_address unless billing_address == SKIP
      @blocked_payment_methods = blocked_payment_methods unless blocked_payment_methods == SKIP
      @capture_delay_hours = capture_delay_hours unless capture_delay_hours == SKIP
      @country_code = country_code unless country_code == SKIP
      @date_of_birth = date_of_birth unless date_of_birth == SKIP
      @deliver_at = deliver_at unless deliver_at == SKIP
      @delivery_address = delivery_address unless delivery_address == SKIP
      @description = description unless description == SKIP
      @expires_at = expires_at unless expires_at == SKIP
      @fund_origin = fund_origin unless fund_origin == SKIP
      @fund_recipient = fund_recipient unless fund_recipient == SKIP
      @installment_options = installment_options unless installment_options == SKIP
      @line_items = line_items unless line_items == SKIP
      @manual_capture = manual_capture unless manual_capture == SKIP
      @mcc = mcc unless mcc == SKIP
      @merchant_account = merchant_account
      @merchant_order_reference = merchant_order_reference unless merchant_order_reference == SKIP
      @metadata = metadata unless metadata == SKIP
      unless platform_chargeback_logic == SKIP
        @platform_chargeback_logic =
          platform_chargeback_logic
      end
      unless recurring_processing_model == SKIP
        @recurring_processing_model =
          recurring_processing_model
      end
      @reference = reference
      @required_shopper_fields = required_shopper_fields unless required_shopper_fields == SKIP
      @return_url = return_url unless return_url == SKIP
      @reusable = reusable unless reusable == SKIP
      @risk_data = risk_data unless risk_data == SKIP
      @shopper_email = shopper_email unless shopper_email == SKIP
      @shopper_locale = shopper_locale unless shopper_locale == SKIP
      @shopper_name = shopper_name unless shopper_name == SKIP
      @shopper_reference = shopper_reference unless shopper_reference == SKIP
      @shopper_statement = shopper_statement unless shopper_statement == SKIP
      unless show_remove_payment_method_button == SKIP
        @show_remove_payment_method_button =
          show_remove_payment_method_button
      end
      @social_security_number = social_security_number unless social_security_number == SKIP
      unless split_card_funding_sources == SKIP
        @split_card_funding_sources =
          split_card_funding_sources
      end
      @splits = splits unless splits == SKIP
      @store = store unless store == SKIP
      unless store_payment_method_mode == SKIP
        @store_payment_method_mode =
          store_payment_method_mode
      end
      @telephone_number = telephone_number unless telephone_number == SKIP
      @theme_id = theme_id unless theme_id == SKIP
      @three_ds2_request_data = three_ds2_request_data unless three_ds2_request_data == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      amount = Amount34.from_hash(hash['amount']) if hash['amount']
      merchant_account =
        hash.key?('merchantAccount') ? hash['merchantAccount'] : nil
      reference = hash.key?('reference') ? hash['reference'] : nil
      allowed_payment_methods =
        hash.key?('allowedPaymentMethods') ? hash['allowedPaymentMethods'] : SKIP
      application_info = ApplicationInfo1.from_hash(hash['applicationInfo']) if
        hash['applicationInfo']
      billing_address = Address3.from_hash(hash['billingAddress']) if hash['billingAddress']
      blocked_payment_methods =
        hash.key?('blockedPaymentMethods') ? hash['blockedPaymentMethods'] : SKIP
      capture_delay_hours =
        hash.key?('captureDelayHours') ? hash['captureDelayHours'] : SKIP
      country_code = hash.key?('countryCode') ? hash['countryCode'] : SKIP
      date_of_birth = hash.key?('dateOfBirth') ? hash['dateOfBirth'] : SKIP
      deliver_at = if hash.key?('deliverAt')
                     (DateTimeHelper.from_rfc3339(hash['deliverAt']) if hash['deliverAt'])
                   else
                     SKIP
                   end
      delivery_address = Address2.from_hash(hash['deliveryAddress']) if hash['deliveryAddress']
      description = hash.key?('description') ? hash['description'] : SKIP
      expires_at = if hash.key?('expiresAt')
                     (DateTimeHelper.from_rfc3339(hash['expiresAt']) if hash['expiresAt'])
                   else
                     SKIP
                   end
      fund_origin = FundOrigin1.from_hash(hash['fundOrigin']) if hash['fundOrigin']
      fund_recipient = FundRecipient1.from_hash(hash['fundRecipient']) if hash['fundRecipient']
      installment_options = InstallmentOption.from_hash(hash['installmentOptions']) if
        hash['installmentOptions']

      installment_options = SKIP unless hash.key?('installmentOptions')
      # Parameter is an array, so we need to iterate through it
      line_items = nil
      unless hash['lineItems'].nil?
        line_items = []
        hash['lineItems'].each do |structure|
          line_items << (LineItem.from_hash(structure) if structure)
        end
      end

      line_items = SKIP unless hash.key?('lineItems')
      manual_capture = hash.key?('manualCapture') ? hash['manualCapture'] : SKIP
      mcc = hash.key?('mcc') ? hash['mcc'] : SKIP
      merchant_order_reference =
        hash.key?('merchantOrderReference') ? hash['merchantOrderReference'] : SKIP
      metadata = hash.key?('metadata') ? hash['metadata'] : SKIP
      if hash['platformChargebackLogic']
        platform_chargeback_logic = PlatformChargebackLogic4.from_hash(hash['platformChargebackLogic'])
      end
      recurring_processing_model =
        hash.key?('recurringProcessingModel') ? hash['recurringProcessingModel'] : SKIP
      required_shopper_fields =
        hash.key?('requiredShopperFields') ? hash['requiredShopperFields'] : SKIP
      return_url = hash.key?('returnUrl') ? hash['returnUrl'] : SKIP
      reusable = hash.key?('reusable') ? hash['reusable'] : SKIP
      risk_data = RiskData1.from_hash(hash['riskData']) if hash['riskData']
      shopper_email = hash.key?('shopperEmail') ? hash['shopperEmail'] : SKIP
      shopper_locale = hash.key?('shopperLocale') ? hash['shopperLocale'] : SKIP
      shopper_name = Name4.from_hash(hash['shopperName']) if hash['shopperName']
      shopper_reference =
        hash.key?('shopperReference') ? hash['shopperReference'] : SKIP
      shopper_statement =
        hash.key?('shopperStatement') ? hash['shopperStatement'] : SKIP
      show_remove_payment_method_button =
        hash['showRemovePaymentMethodButton'] ||= true
      social_security_number =
        hash.key?('socialSecurityNumber') ? hash['socialSecurityNumber'] : SKIP
      split_card_funding_sources = hash['splitCardFundingSources'] ||= false
      # Parameter is an array, so we need to iterate through it
      splits = nil
      unless hash['splits'].nil?
        splits = []
        hash['splits'].each do |structure|
          splits << (Split.from_hash(structure) if structure)
        end
      end

      splits = SKIP unless hash.key?('splits')
      store = hash.key?('store') ? hash['store'] : SKIP
      store_payment_method_mode =
        hash.key?('storePaymentMethodMode') ? hash['storePaymentMethodMode'] : SKIP
      telephone_number =
        hash.key?('telephoneNumber') ? hash['telephoneNumber'] : SKIP
      theme_id = hash.key?('themeId') ? hash['themeId'] : SKIP
      if hash['threeDS2RequestData']
        three_ds2_request_data = CheckoutSessionThreeDs2RequestData3.from_hash(hash['threeDS2RequestData'])
      end

      # Create object from extracted values.
      PaymentLinkRequest.new(amount: amount,
                             merchant_account: merchant_account,
                             reference: reference,
                             allowed_payment_methods: allowed_payment_methods,
                             application_info: application_info,
                             billing_address: billing_address,
                             blocked_payment_methods: blocked_payment_methods,
                             capture_delay_hours: capture_delay_hours,
                             country_code: country_code,
                             date_of_birth: date_of_birth,
                             deliver_at: deliver_at,
                             delivery_address: delivery_address,
                             description: description,
                             expires_at: expires_at,
                             fund_origin: fund_origin,
                             fund_recipient: fund_recipient,
                             installment_options: installment_options,
                             line_items: line_items,
                             manual_capture: manual_capture,
                             mcc: mcc,
                             merchant_order_reference: merchant_order_reference,
                             metadata: metadata,
                             platform_chargeback_logic: platform_chargeback_logic,
                             recurring_processing_model: recurring_processing_model,
                             required_shopper_fields: required_shopper_fields,
                             return_url: return_url,
                             reusable: reusable,
                             risk_data: risk_data,
                             shopper_email: shopper_email,
                             shopper_locale: shopper_locale,
                             shopper_name: shopper_name,
                             shopper_reference: shopper_reference,
                             shopper_statement: shopper_statement,
                             show_remove_payment_method_button: show_remove_payment_method_button,
                             social_security_number: social_security_number,
                             split_card_funding_sources: split_card_funding_sources,
                             splits: splits,
                             store: store,
                             store_payment_method_mode: store_payment_method_mode,
                             telephone_number: telephone_number,
                             theme_id: theme_id,
                             three_ds2_request_data: three_ds2_request_data)
    end

    def to_custom_deliver_at
      DateTimeHelper.to_rfc3339(deliver_at)
    end

    def to_custom_expires_at
      DateTimeHelper.to_rfc3339(expires_at)
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} allowed_payment_methods: #{@allowed_payment_methods}, amount: #{@amount},"\
      " application_info: #{@application_info}, billing_address: #{@billing_address},"\
      " blocked_payment_methods: #{@blocked_payment_methods}, capture_delay_hours:"\
      " #{@capture_delay_hours}, country_code: #{@country_code}, date_of_birth: #{@date_of_birth},"\
      " deliver_at: #{@deliver_at}, delivery_address: #{@delivery_address}, description:"\
      " #{@description}, expires_at: #{@expires_at}, fund_origin: #{@fund_origin}, fund_recipient:"\
      " #{@fund_recipient}, installment_options: #{@installment_options}, line_items:"\
      " #{@line_items}, manual_capture: #{@manual_capture}, mcc: #{@mcc}, merchant_account:"\
      " #{@merchant_account}, merchant_order_reference: #{@merchant_order_reference}, metadata:"\
      " #{@metadata}, platform_chargeback_logic: #{@platform_chargeback_logic},"\
      " recurring_processing_model: #{@recurring_processing_model}, reference: #{@reference},"\
      " required_shopper_fields: #{@required_shopper_fields}, return_url: #{@return_url},"\
      " reusable: #{@reusable}, risk_data: #{@risk_data}, shopper_email: #{@shopper_email},"\
      " shopper_locale: #{@shopper_locale}, shopper_name: #{@shopper_name}, shopper_reference:"\
      " #{@shopper_reference}, shopper_statement: #{@shopper_statement},"\
      " show_remove_payment_method_button: #{@show_remove_payment_method_button},"\
      " social_security_number: #{@social_security_number}, split_card_funding_sources:"\
      " #{@split_card_funding_sources}, splits: #{@splits}, store: #{@store},"\
      " store_payment_method_mode: #{@store_payment_method_mode}, telephone_number:"\
      " #{@telephone_number}, theme_id: #{@theme_id}, three_ds2_request_data:"\
      " #{@three_ds2_request_data}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} allowed_payment_methods: #{@allowed_payment_methods.inspect}, amount:"\
      " #{@amount.inspect}, application_info: #{@application_info.inspect}, billing_address:"\
      " #{@billing_address.inspect}, blocked_payment_methods: #{@blocked_payment_methods.inspect},"\
      " capture_delay_hours: #{@capture_delay_hours.inspect}, country_code:"\
      " #{@country_code.inspect}, date_of_birth: #{@date_of_birth.inspect}, deliver_at:"\
      " #{@deliver_at.inspect}, delivery_address: #{@delivery_address.inspect}, description:"\
      " #{@description.inspect}, expires_at: #{@expires_at.inspect}, fund_origin:"\
      " #{@fund_origin.inspect}, fund_recipient: #{@fund_recipient.inspect}, installment_options:"\
      " #{@installment_options.inspect}, line_items: #{@line_items.inspect}, manual_capture:"\
      " #{@manual_capture.inspect}, mcc: #{@mcc.inspect}, merchant_account:"\
      " #{@merchant_account.inspect}, merchant_order_reference:"\
      " #{@merchant_order_reference.inspect}, metadata: #{@metadata.inspect},"\
      " platform_chargeback_logic: #{@platform_chargeback_logic.inspect},"\
      " recurring_processing_model: #{@recurring_processing_model.inspect}, reference:"\
      " #{@reference.inspect}, required_shopper_fields: #{@required_shopper_fields.inspect},"\
      " return_url: #{@return_url.inspect}, reusable: #{@reusable.inspect}, risk_data:"\
      " #{@risk_data.inspect}, shopper_email: #{@shopper_email.inspect}, shopper_locale:"\
      " #{@shopper_locale.inspect}, shopper_name: #{@shopper_name.inspect}, shopper_reference:"\
      " #{@shopper_reference.inspect}, shopper_statement: #{@shopper_statement.inspect},"\
      " show_remove_payment_method_button: #{@show_remove_payment_method_button.inspect},"\
      " social_security_number: #{@social_security_number.inspect}, split_card_funding_sources:"\
      " #{@split_card_funding_sources.inspect}, splits: #{@splits.inspect}, store:"\
      " #{@store.inspect}, store_payment_method_mode: #{@store_payment_method_mode.inspect},"\
      " telephone_number: #{@telephone_number.inspect}, theme_id: #{@theme_id.inspect},"\
      " three_ds2_request_data: #{@three_ds2_request_data.inspect}>"
    end
  end
end
